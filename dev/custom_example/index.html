<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom Example · ABMPredictionMarkets</title><meta name="title" content="Custom Example · ABMPredictionMarkets"/><meta property="og:title" content="Custom Example · ABMPredictionMarkets"/><meta property="twitter:title" content="Custom Example · ABMPredictionMarkets"/><meta name="description" content="Documentation for ABMPredictionMarkets."/><meta property="og:description" content="Documentation for ABMPredictionMarkets."/><meta property="twitter:description" content="Documentation for ABMPredictionMarkets."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ABMPredictionMarkets logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ABMPredictionMarkets</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../basic_example/">Basic Example</a></li><li class="is-active"><a class="tocitem" href>Custom Example</a><ul class="internal"><li><a class="tocitem" href="#Sub-Additivity"><span>Sub-Additivity</span></a></li><li><a class="tocitem" href="#Load-Dependencies"><span>Load Dependencies</span></a></li><li><a class="tocitem" href="#Define-Agents"><span>Define Agents</span></a></li><li><a class="tocitem" href="#Agent-Step-Function"><span>Agent Step Function</span></a></li><li><a class="tocitem" href="#Arbitrage-Functions"><span>Arbitrage Functions</span></a></li><li><a class="tocitem" href="#Model-Initialization-Function"><span>Model Initialization Function</span></a></li><li><a class="tocitem" href="#Initialize-Models"><span>Initialize Models</span></a></li><li><a class="tocitem" href="#Run-Models"><span>Run Models</span></a></li><li><a class="tocitem" href="#Plot-Results"><span>Plot Results</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Custom Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Custom Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/itsdfish/ABMPredictionMarkets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/itsdfish/ABMPredictionMarkets.jl/blob/main/docs/src/custom_example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Custom-Example"><a class="docs-heading-anchor" href="#Custom-Example">Custom Example</a><a id="Custom-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Example" title="Permalink"></a></h1><p>The purpose of this tutorial is to demonstrate how to create an agent with custom behavior. The example below consists of two agent types: </p><ol><li><code>subadditive agent</code>: an agent whose beliefs about a set of prediction markets are subadditive (i.e., exceeds 1), and thus violate probability theory.</li><li><code>arbitrage agent</code>: an agent who exploits subadditive markets by purchasing <em>no shares</em> in each market.</li></ol><p>Our example will demonstrate the value of arbitrage in correcting prices by comparing two conditions: (1) a <em>no arbitrage condition</em> consisting of 100 subadditive agents and zero arbitrage agents, and (2) an <em>arbitrage condition</em> consisting of 70 subadditive agents and 30 arbitrage agents. In the <em>arbigtrage condition</em>, the arbitrage agents will reduce subadditivity by renormalizing the market prices. </p><h2 id="Sub-Additivity"><a class="docs-heading-anchor" href="#Sub-Additivity">Sub-Additivity</a><a id="Sub-Additivity-1"></a><a class="docs-heading-anchor-permalink" href="#Sub-Additivity" title="Permalink"></a></h2><p>In this section, we provide a more formal explanation of subadditivity. Suppose the sample space <span>$\boldsymbol{\Omega}$</span> is partitioned into a set of mutually exclusive and exhaustive sub-events: <span>$\boldsymbol{\Omega} = \{e_1,e_2, \dots, e_n\}$</span>. According to probability theory, the probabilities must be additive:  </p><p class="math-container">\[p(e_1 \cup e_2 \cup \dots \cup e_n) = \sum_{e_i \in \boldsymbol{\Omega}} p(e_i) = 1\]</p><p>In other words, the sum of the probabilities across all sub-events must sum to 1. This logic extends to prediction markets because the market price is interpreted as a crowd sourced probability estimate.  Below, we will create a set of binary prediction markets covering events in <span>$\boldsymbol{\Omega}$</span>: </p><p class="math-container">\[\mathbf{M} = \{(e_1, \bar{e_1}),(e_2, \bar{e_2}), \dots, (e_n, \bar{e_n})\}.\]</p><p>Each market consists of and event <span>$e_i$</span> represented by <em>yes shares</em> and its complementary event <span>$\bar{e_i}$</span> represented by <em>no shares</em>. If additivity is satisfied, the sum of <em>yes prices</em> should approximate 1 at each time point. </p><p>Click on the ▶ icon to reveal a full version of the code.  </p><details>
<summary><b>Full Code</b></summary><pre><code class="language-julia hljs">using ABMPredictionMarkets
using ABMPredictionMarkets: get_market
using ABMPredictionMarkets: get_min_ask
using ABMPredictionMarkets: init
using ABMPredictionMarkets: transact!
using Agents
using Plots
using Random
using Statistics
import ABMPredictionMarkets: agent_step!

@agent struct SubadditiveAgent(NoSpaceAgent) &lt;: MarketAgent
    judgments::Vector{Int}
    δ::Int
    money::Int
    bid_reserve::Int
    max_quantity::Int
    shares::Vector{Vector{Order}}
end

@agent struct ArbitrageAgent(NoSpaceAgent) &lt;: MarketAgent
    money::Int
    bid_reserve::Int
    shares::Vector{Vector{Order}}
end


@multiagent MultiAgent(ArbitrageAgent, SubadditiveAgent) &lt;: MarketAgent

function agent_step!(agent, ::ArbitrageAgent, ::AbstractPredictionMarket, model)
    no_prices = get_no_prices(model)
    cost, win = eval_arbitrage(no_prices, 0)
    if (cost &lt; win) &amp;&amp; (agent.money ≥ cost)
        for bidx ∈ 1:length(model.order_books)
            price = no_prices[bidx]
            agent.bid_reserve += price
            agent.money -= price
            order = Order(;id = agent.id, yes = false, price, quantity = 1, type = :bid)
            transact!(order, model, bidx)
        end
    else
        for bidx ∈ 1:length(model.order_books) 
            push!(model.trade_counts[bidx], 0)
            push!(model.iteration_ids[bidx], abmtime(model))
            market_prices = model.market_prices[bidx]
            isempty(market_prices) ? push!(market_prices, NaN) :
            push!(market_prices, market_prices[end])
        end
    end
    return nothing
end

function eval_arbitrage(no_prices, fee_percent)
    n_win = length(no_prices) - 1
    win = n_win * 100
    cost = sum(no_prices)
    fees = sum(compute_fee.(fee_percent, sort(no_prices[1:n_win])))
    return (;cost, win = win - fees)
end

compute_fee(fee_percent, price) = fee_percent * min(price, 100 - price) * (100 / price)

function get_no_prices(model)
    return get_min_ask.(model.order_books; yes = false)
end

function initialize(
    standard_type::Type{&lt;:SubadditiveAgent},
    arbitrage_type::Type{&lt;:ArbitrageAgent};
    n_subadditive,
    n_arbitrage,
    μ,
    η,
    δ,
    money,
    max_quantity = 1,
    unpacking_factor,
    info_times = Int[]
)
    space = nothing
    n_markets = length(μ)
    model = StandardABM(
        MultiAgent,
        space;
        properties = CDA(; n_markets, info_times),
        agent_step!,
        scheduler = Schedulers.Randomly()
    )
    id = 0
    for _ ∈ 1:n_subadditive
        id += 1
        judgments = Int.(round.(rand(DiscreteDirichlet(μ, η)) * unpacking_factor))
        agent = (MultiAgent ∘ standard_type)(;
            id,
            judgments,
            money,
            bid_reserve = 0,
            δ,
            max_quantity,
            shares = init(Order, n_markets)
        )
        add_agent!(agent, model)
    end
    for _ ∈ 1:n_arbitrage
        id += 1
        agent = (MultiAgent ∘ arbitrage_type)(;
            id,
            money,
            bid_reserve = 0,
            shares = init(Order, n_markets)
        )
        add_agent!(agent, model)
    end
    return model
end

Random.seed!(5064)

config = (
    μ = [0.45, 0.20, 0.25, 0.10],
    η = 20.0,
    unpacking_factor = 1.3,
    δ = 3,
    money = 5000,
    max_quantity = 1,
)

no_arbitrage_model = initialize(
    SubadditiveAgent,
    ArbitrageAgent;
    n_subadditive = 100,
    n_arbitrage = 0,
    config...
)

arbitrage_model = initialize(
    SubadditiveAgent,
    ArbitrageAgent;
    n_subadditive = 70,
    n_arbitrage = 30,
    config...
)

run!(no_arbitrage_model, 100)
run!(arbitrage_model, 100)

no_arbitrage_market_prices = summarize_by_iteration.(no_arbitrage_model.market_prices, no_arbitrage_model.iteration_ids)

plot(
    sum(no_arbitrage_market_prices),
    ylims = (0, 2),
    xlabel = &quot;Day&quot;, 
    ylabel = &quot;Unpacking Factor&quot;,
    grid = false,
    label = &quot;No Arbitriage&quot;,
)
hline!([1], color = :black, linestyle = :dash, label = nothing)

arbitrage_market_prices = summarize_by_iteration.(arbitrage_model.market_prices, arbitrage_model.iteration_ids)
plot!(sum(arbitrage_market_prices), label = &quot;Arbitriage&quot;)</code></pre></details><h2 id="Load-Dependencies"><a class="docs-heading-anchor" href="#Load-Dependencies">Load Dependencies</a><a id="Load-Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Dependencies" title="Permalink"></a></h2><p>Our first step is to load the required dependencies for simulation and plotting. In addition, we will import the function <code>agent_step!</code> so we can create a new method defining the behavior of the subadditive agent. </p><pre><code class="language-julia hljs">using ABMPredictionMarkets
using ABMPredictionMarkets: get_market
using ABMPredictionMarkets: get_min_ask
using ABMPredictionMarkets: init
using ABMPredictionMarkets: transact!
using Agents
using Plots
using Random
using Statistics
import ABMPredictionMarkets: agent_step!</code></pre><h2 id="Define-Agents"><a class="docs-heading-anchor" href="#Define-Agents">Define Agents</a><a id="Define-Agents-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Agents" title="Permalink"></a></h2><p>Below, we define agent types which is are subtype of <code>MarketAgent</code>. </p><h3 id="Subadditive-Agents"><a class="docs-heading-anchor" href="#Subadditive-Agents">Subadditive Agents</a><a id="Subadditive-Agents-1"></a><a class="docs-heading-anchor-permalink" href="#Subadditive-Agents" title="Permalink"></a></h3><p>As the name implies, the probability judgments of the subadditive agent are subadditive. The subadditive agent has the following fields:</p><ul><li><code>judgments::Vector{Int}</code>: a vector of probabilities for each event expressed in cents, which sum to a value greater than 100 because they are subadditive. </li><li><code>δ::Int</code>: the degree of variability in bids and asks expressed in cents. </li><li><code>money::Int</code>: the amount of money available to the agent expressed in cents. </li><li><code>bid_reserve::Int</code>: the amount of money reserved for bids in the order book for ensuring sufficient funds</li><li><code>max_quantity::Int</code> the maximum quantity of shares per order</li><li><code>shares::Vector{Vector{Order}}</code>: a constaining for storing the shares owned by the agent. Each sub-vector corresponds to a shares for a sub-event. </li></ul><p>On each simulated day when the function <code>agent_step!</code> is called for a subadditive agent, it submits a bid or ask in each available market. Roughly speaking, it accepts the maximum bid or minimum ask if it is advantageous. Otherwise, it submits an order for an ask or bid with uniform variable and a range of <span>$\delta$</span> cents. </p><pre><code class="language-julia hljs">@agent struct SubadditiveAgent(NoSpaceAgent) &lt;: MarketAgent
    judgments::Vector{Int}
    δ::Int
    money::Int
    bid_reserve::Int
    max_quantity::Int
    shares::Vector{Vector{Order}}
end</code></pre><h3 id="Arbitrage-Agent"><a class="docs-heading-anchor" href="#Arbitrage-Agent">Arbitrage Agent</a><a id="Arbitrage-Agent-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrage-Agent" title="Permalink"></a></h3><p>The goal of the arbitrage agent is to exploit sub-additive prices by purchacing <em>no</em> shares for all markets. Using this strategy guarantees a payout of 1 dollar for <span>$n-1$</span> shares, i.e., all shares except the share whose complementary event occured. Assuming prices are sub-additive (i.e., <span>$\sum_{i=1}^n e_i&lt; 1$</span>), then the cost of <em>no</em> shares for all markets, <em>c</em>,  must be less than the payout: <span>$c &lt; n - 1$</span>. </p><details>
<summary><b>Mathematical Details</b></summary><p>To see why, note the cost <span>$c$</span> is</p><p class="math-container">\[c = \sum_{i=1}^n \bar{e}_i\]</p><p class="math-container">\[c = \sum_{i=1}^n 1 - e_i\]</p><p class="math-container">\[c = \sum_{i=1}^n 1 - \sum_{i=1}^n e_i\]</p><p class="math-container">\[c = n - \sum_{i=1}^n e_i.\]</p><p>Substituting <span>$n - \sum_{i=1}^n e_i$</span> into <span>$c &lt; n-1$</span>, we have</p><p class="math-container">\[n - \sum_{i=1}^n e_i &lt; n - 1\]</p><p class="math-container">\[\sum_{i=1}^n e_i &gt; 1,\]</p><p>which is consistent with our assumption of sub-additivity.</p></details><p>The arbitrage agent has a subset of fields defined above for the subadditive agent. </p><pre><code class="language-julia hljs">@agent struct ArbitrageAgent(NoSpaceAgent) &lt;: MarketAgent
    money::Int
    bid_reserve::Int
    shares::Vector{Vector{Order}}
end</code></pre><h3 id="Multi-Agent"><a class="docs-heading-anchor" href="#Multi-Agent">Multi-Agent</a><a id="Multi-Agent-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Agent" title="Permalink"></a></h3><p>To improve performance, we will wrap the two agent types into a <code>MultiAgent</code> type with the <code>@multiagent</code> macro.</p><pre><code class="language-julia hljs">@multiagent MultiAgent(ArbitrageAgent, SubadditiveAgent) &lt;: MarketAgent</code></pre><h2 id="Agent-Step-Function"><a class="docs-heading-anchor" href="#Agent-Step-Function">Agent Step Function</a><a id="Agent-Step-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-Step-Function" title="Permalink"></a></h2><p>The behavior of the arbitrage agent in the <code>agent_step!</code> method below. The function works as follows. First, the agent determines whether it can exploit subadditive prices. Second, if it can, it submits an order for a <em>no share</em> in each market. Otherwise, it records the previous market price as the current market price. </p><pre><code class="language-julia hljs">function agent_step!(agent, ::ArbitrageAgent, ::AbstractPredictionMarket, model)
    no_prices = get_no_prices(model)
    cost, win = eval_arbitrage(no_prices, 0)
    if (cost &lt; win) &amp;&amp; (agent.money ≥ cost)
        for bidx ∈ 1:length(model.order_books)
            price = no_prices[bidx]
            agent.bid_reserve += price
            agent.money -= price
            order = Order(;id = agent.id, yes = false, price, quantity = 1, type = :bid)
            transact!(order, model, bidx)
        end
    else
        for bidx ∈ 1:length(model.order_books)
            push!(model.trade_counts[bidx], 0)
            push!(model.iteration_ids[bidx], abmtime(model))
            market_prices = model.market_prices[bidx]
            isempty(market_prices) ? push!(market_prices, NaN) :
            push!(market_prices, market_prices[end])
        end
    end
    return nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">agent_step! (generic function with 4 methods)</code></pre><h2 id="Arbitrage-Functions"><a class="docs-heading-anchor" href="#Arbitrage-Functions">Arbitrage Functions</a><a id="Arbitrage-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrage-Functions" title="Permalink"></a></h2><p>The code block defines three helper functions for arbitrage. Given a vector of <em>no prices</em> and a free percent, the function <code>eval_arbitrage</code> returns the cost and the payout for buying <em>no shares</em> in each prediction market. The function <code>compute_fee</code> returns the fees Polymarket applies to winnings. In our example, we assume for simplicity that the fee is zero percent. Finally, the function <code>get_all_no_prices</code> returns a vector of asking prices for <em>no shares</em> in each market. </p><pre><code class="language-julia hljs">function eval_arbitrage(no_prices, fee_percent)
    n_win = length(no_prices) - 1
    win = n_win * 100
    cost = sum(no_prices)
    fees = sum(compute_fee.(fee_percent, sort(no_prices[1:n_win])))
    return (;cost, win = win - fees)
end

compute_fee(fee_percent, price) = fee_percent * min(price, 100 - price) * (100 / price)

function get_no_prices(model)
    return get_min_ask.(model.order_books; yes = false)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_no_prices (generic function with 1 method)</code></pre><h2 id="Model-Initialization-Function"><a class="docs-heading-anchor" href="#Model-Initialization-Function">Model Initialization Function</a><a id="Model-Initialization-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Initialization-Function" title="Permalink"></a></h2><p>In the code block below, we define a function that initializes the model and adds agents to the newly created model. The model has no spatial component because agents do not need to move in their environment. The model uses a type of prediction market called a continuous double action (see the type <code>CDA</code>). In addition, the scheduler randomizes the order in each agents perform their actions on each day. The function requires the following keyword arguments:</p><ul><li><code>n_subadditive</code>: the number of subadditive agents in the simulation</li><li><code>n_arbitrage</code>: the number of arbitrage agents in the simulation</li><li><code>μ</code>: the mean probability judgments sampled from a Dirichlet distribution</li><li><code>η</code>: the precession of probability judgments sampled from a Dirichlet distribution</li><li><code>δ::Int</code>: the degree of variability in bids and asks expressed in cents. </li><li><code>money</code>: the initial amount of money given to each agent</li><li><code>max_quantity = 1</code>: the maximum number of shares per order for each agent per day</li><li><code>unpacking_factor</code>: controls the degree of subadditivity in the judgments of the subadditive agents</li><li><code>info_times = Int[]</code>: required keyword argument that is not needed for this model</li></ul><pre><code class="language-julia hljs">function initialize(
    standard_type::Type{&lt;:SubadditiveAgent},
    arbitrage_type::Type{&lt;:ArbitrageAgent};
    n_subadditive,
    n_arbitrage,
    μ,
    η,
    δ,
    money,
    max_quantity = 1,
    unpacking_factor,
    info_times = Int[]
)
    space = nothing
    n_markets = length(μ)
    model = StandardABM(
        MultiAgent,
        space;
        properties = CDA(; n_markets, info_times),
        agent_step!,
        scheduler = Schedulers.Randomly()
    )
    id = 0
    for _ ∈ 1:n_subadditive
        id += 1
        judgments = Int.(round.(rand(DiscreteDirichlet(μ, η)) * unpacking_factor))
        agent = (MultiAgent ∘ standard_type)(;
            id,
            judgments,
            money,
            bid_reserve = 0,
            δ,
            max_quantity,
            shares = init(Order, n_markets)
        )
        add_agent!(agent, model)
    end
    for _ ∈ 1:n_arbitrage
        id += 1
        agent = (MultiAgent ∘ arbitrage_type)(;
            id,
            money,
            bid_reserve = 0,
            shares = init(Order, n_markets)
        )
        add_agent!(agent, model)
    end
    return model
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">initialize (generic function with 1 method)</code></pre><h3 id="Set-RNG-Seed"><a class="docs-heading-anchor" href="#Set-RNG-Seed">Set RNG Seed</a><a id="Set-RNG-Seed-1"></a><a class="docs-heading-anchor-permalink" href="#Set-RNG-Seed" title="Permalink"></a></h3><p>The next code block sets the seed for the random number generator to ensure the results are reproducible. </p><pre><code class="language-julia hljs">Random.seed!(5064)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.TaskLocalRNG()</code></pre><h2 id="Initialize-Models"><a class="docs-heading-anchor" href="#Initialize-Models">Initialize Models</a><a id="Initialize-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-Models" title="Permalink"></a></h2><p>In this section, we create models for the <em>no arbitrage condition</em> and the <em>arbitrage condition</em> with the function called <code>initialize</code>. The code block below defines a <code>NamedTuple</code> of the common parameters for each model. </p><pre><code class="language-julia hljs">config = (
    μ = [0.45, 0.20, 0.25, 0.10],
    η = 20.0,
    unpacking_factor = 1.3,
    δ = 3,
    money = 5000,
    max_quantity = 1,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(μ = [0.45, 0.2, 0.25, 0.1], η = 20.0, unpacking_factor = 1.3, δ = 3, money = 5000, max_quantity = 1)</code></pre><h3 id="No-Arbitrage-Model"><a class="docs-heading-anchor" href="#No-Arbitrage-Model">No Arbitrage Model</a><a id="No-Arbitrage-Model-1"></a><a class="docs-heading-anchor-permalink" href="#No-Arbitrage-Model" title="Permalink"></a></h3><p>The defining feature of the <em>no arbitrage model</em> is the absence of arbitrage agents. Specifically, we set the number of subadditive agents to 100 and the number of arbitrage agents to 0. </p><pre><code class="language-julia hljs">no_arbitrage_model = initialize(
    SubadditiveAgent,
    ArbitrageAgent;
    n_subadditive = 100,
    n_arbitrage = 0,
    config...
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 100 agents of type MultiAgent
 agents container: Dict
 space: nothing (no spatial structure)
 scheduler: Agents.Schedulers.Randomly
 properties: order_books, market_prices, info_times, trade_counts, iteration_ids</code></pre><h3 id="Arbitrage-Model"><a class="docs-heading-anchor" href="#Arbitrage-Model">Arbitrage Model</a><a id="Arbitrage-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrage-Model" title="Permalink"></a></h3><p>By contrast, the <em>arbitrage model</em> does include arbitrage agents. Specifically, we set the number of subadditive agents to 70 and the number of arbitrage agents to 30. </p><pre><code class="language-julia hljs">arbitrage_model = initialize(
    SubadditiveAgent,
    ArbitrageAgent;
    n_subadditive = 70,
    n_arbitrage = 30,
    config...
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 100 agents of type MultiAgent
 agents container: Dict
 space: nothing (no spatial structure)
 scheduler: Agents.Schedulers.Randomly
 properties: order_books, market_prices, info_times, trade_counts, iteration_ids</code></pre><h2 id="Run-Models"><a class="docs-heading-anchor" href="#Run-Models">Run Models</a><a id="Run-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Run-Models" title="Permalink"></a></h2><p>In the code block below, we run each model for 100 days. Agents sequentially perform their actions in a different random order each day. </p><pre><code class="language-julia hljs">run!(no_arbitrage_model, 100)
run!(arbitrage_model, 100)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(<span class="sgr1">0×0 DataFrame, 0×0 DataFrame)</span></code></pre><h2 id="Plot-Results"><a class="docs-heading-anchor" href="#Plot-Results">Plot Results</a><a id="Plot-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Results" title="Permalink"></a></h2><p>In the plot below, we plot the ending market price each day for the <em>no arbitrage</em> and <em>arbitrage</em> models. As expected, both models show evidence of subadditivity (i.e., the data points are above 1), but the degree of subadditivity is less pronounced in the arbitrage model, indicating arbitrage agents were able to exploit the mispriced markets and partially correct the prices.</p><pre><code class="language-julia hljs">no_arbitrage_market_prices = summarize_by_iteration.(no_arbitrage_model.market_prices, no_arbitrage_model.iteration_ids)
plot(
    sum(no_arbitrage_market_prices),
    ylims = (0, 2),
    xlabel = &quot;Day&quot;,
    ylabel = &quot;Unpacking Factor&quot;,
    grid = false,
    label = &quot;No Arbitriage&quot;,
)
hline!([1], color = :black, linestyle = :dash, label = nothing)
arbitrage_market_prices = summarize_by_iteration.(arbitrage_model.market_prices, arbitrage_model.iteration_ids)
plot!(sum(arbitrage_market_prices), label = &quot;Arbitriage&quot;)</code></pre><img src="2cb3fa46.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basic_example/">« Basic Example</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Saturday 24 May 2025 19:03">Saturday 24 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
