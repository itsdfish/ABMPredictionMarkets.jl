var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/#ABMPredictionMarkets.AMMOrder","page":"API","title":"ABMPredictionMarkets.AMMOrder","text":"AMMOrder <: AbstractOrder\n\nAn object representing a bid, ask, or share. \n\nFields\n\nid::Int: agent id \noption_id: option id\ncost::Float64: total cost of order\nn_shares: the number of shares in the order\n\nConstructors\n\nAMMOrder(id, option, cost, n_shares)\n\nAMMOrder(; id, option, cost, n_shares)\n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.AbstractCDA","page":"API","title":"ABMPredictionMarkets.AbstractCDA","text":"AbstractCDA <: AbstractPredictionMarket\n\nAn abstract type for a continuous double auction prediction market. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.AbstractCPMM","page":"API","title":"ABMPredictionMarkets.AbstractCPMM","text":"AbstractCPMM <: AbstractPredictionMarket\n\nAn abstract type for a prediction market using a constant product market maker. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.AbstractLSR","page":"API","title":"ABMPredictionMarkets.AbstractLSR","text":"AbstractLSR <: AbstractPredictionMarket\n\nAn abstract type for a prediction market using a logarithmic scoring rule. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.AbstractOrder","page":"API","title":"ABMPredictionMarkets.AbstractOrder","text":"AbstractOrder\n\nAn abstract type representing bids and asks. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.AbstractPredictionMarket","page":"API","title":"ABMPredictionMarkets.AbstractPredictionMarket","text":"AbstractPredictionMarket\n\nAn abstract type for a prediction market. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.CDA","page":"API","title":"ABMPredictionMarkets.CDA","text":"CDA <: AbstractCDA\n\nHolds data and order book for a continuous double auction prediction market simulation.\n\nFields\n\norder_books::Vector{Vector{Order}}: outstanding orders (bids and asks). Each sub-vector corresponds to a different market\nmarket_prices::Vector{Vector{Float64}}: the market price in dollars after each interaction. The market price stays the same   if a transaction does not occur. Each sub-vector corresponds to a different market\ntrade_volume::Vector{Vector{Int}}: each elements represents the number of trades made per step\niteration_ids::Vector{Vector{Int}}`: iteration number on which market prices are recorded\ntimes::Vector{Int} = Int[]: times at which specific events may occur\n\nConstructors\n\nCDA(; order_book)\n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.CPMM","page":"API","title":"ABMPredictionMarkets.CPMM","text":"CPMM <: AbstractCPMM\n\nHolds reserves and data for a constant product market maker prediction market simulation.\n\nFields\n\nyes_reserves::Vector{Float64}: reserves for \"yes\" shares. Each element corresponds to a different market\nno_reserves::Vector{Float64}: reserves for \"no\" shares. Each element corresponds to a different market\nmarket_prices::Vector{Vector{Float64}}: the market price in dollars after each interaction. The market price stays the same   if a transaction does not occur. Each sub-vector corresponds to a different market\ntrade_volume::Vector{Vector{Int}}: each elements represents the number of trades made per step\niteration_ids::Vector{Vector{Int}}`: iteration number on which market prices are recorded\ntimes::Vector{Int} = Int[]: times at which specific events may occur\n\nConstructors\n\nCPMM(; yes_reserves, no_reserves, times = Int[])\n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.DiscreteDirichlet","page":"API","title":"ABMPredictionMarkets.DiscreteDirichlet","text":"DiscreteDirichlet{T} <: ContinuousMultivariateDistribution\n\nA discrete version of Dirchlet distribution which sums to 100. \n\nFields\n\nμ::Vector{T}: mean probabilities which sum to 1\nη::T: a scalar multiple of μ inversely related to variance. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.LSR","page":"API","title":"ABMPredictionMarkets.LSR","text":"LSR <: AbstractLSR\n\nAn automated market maker using the logarithmic scoring rule.\n\nFields\n\nelasticity: elasticity parameter where higher values correspond to less elasticity\nn_shares::Vector{Vector{Int}}: each sub-vector corresponds to the number of shares for each option in a given market\nmarket_prices::Vector{Vector{Vector{Float64}}}: the market price in dollars after each interaction. The market price stays the same   if a transaction does not occur. Each sub-vector corresponds to a different market at a different iteration. \nn_decimals::Int: decimal places for rounding in favor of the automated market maker\ntrade_volume::Vector{Vector{Int}}: each elements represents the number of trades made per step\niteration_ids::Vector{Vector{Int}}`: iteration number on which market prices are recorded\ntimes::Vector{Int} = Int[]: times at which specific events may occur\n\nConstructors\n\nLSR(; elasticity, n_options, info_times)\n\nReferences\n\nBerg, H., & Proebsting, T. A. (2009). Hanson’s automated market maker. The Journal of Prediction Markets, 3(1), 45-59.\n\nHanson, R. (2003). Combinatorial information market design. Information Systems Frontiers, 5, 107-119.\n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.MarketAgent","page":"API","title":"ABMPredictionMarkets.MarketAgent","text":"MarketAgent <: AbstractAgent\n\nAn agent that submits bids and asks in a prediction market. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.Order","page":"API","title":"ABMPredictionMarkets.Order","text":"Order <: AbstractOrder\n\nAn object representing a bid, ask, or share. \n\nFields\n\nid::Int: agent id \nyes::Bool: true if represents a yes share \nprice::Int: the price of a single share, price ∈ [0,100]\nquantity::Int: the number of shares at a given price \ntype::Symbol: object type type ∈ [bid,ask,share]\n\nConstructors\n\nOrder(id, yes, price, quantity, type)\n\nOrder(; id, yes, price, quantity, type)\n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.agent_step!-Tuple{Any, MarketAgent, AbstractPredictionMarket, Any}","page":"API","title":"ABMPredictionMarkets.agent_step!","text":"agent_step!(agent, ::MarketAgent, ::AbstractPredictionMarket, model)\n\nThe agent submits a new order for a bid or ask in each market.  The order is checked against potential sellers (buyers), and  an exchange is made if one is found. Otherwise, the order is added to the order book.    \n\nArguments\n\nagent: an agent participating in the prediction market\n::MarketAgent: variant of agent possibly of the same type as agent\n::AbstractPredictionMarket: a prediction market type \nmodel: an abm object for the prediction market simulation \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.compute_trade_volume-Tuple{Any, Int64}","page":"API","title":"ABMPredictionMarkets.compute_trade_volume","text":"compute_trade_volume(trade_volume, interval_length)\n\nComputes trade volume for a set of time intervals \n\nArguments\n\ntrade_volume: indicates number of trades per step\ninterval_length: the length of the interval in which trade volume is computed\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.compute_unpacking_factor-Tuple{Any}","page":"API","title":"ABMPredictionMarkets.compute_unpacking_factor","text":"compute_unpacking_factor(model)\n\nComputes the ratio of sum of subevents probabilities to the event probability for a 2×2 partition.  Event e is indexed by 1 and subevents e₁ and e₂ are indexed by 2 and 3. Probability theory requires p(e) = p(e₁) + p(e₂).\n\nArguments \n\nmodel: an abm object for the prediction market simulation \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.summarize_by_iteration-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.summarize_by_iteration","text":"summarize_by_iteration(values, iteration_ids; fun = x -> x[end])\n\nSummarize by iteration using fun\n\nArguments\n\nvalues: a vector of values after each agent step \niteration_ids: a vector containing the indices of iterations for each agent step \n\nKeywords\n\nfun = x -> x[end]: a function applied to market prices of each iteration. By default,\n\nthe ending price is used. \n\n\n\n\n\n","category":"method"},{"location":"api/#Plotting","page":"API","title":"Plotting","text":"","category":"section"},{"location":"api/#ABMPredictionMarkets.plot_depth_chart","page":"API","title":"ABMPredictionMarkets.plot_depth_chart","text":"plot_depth_chart(order_book::Vector{Order}; kwargs...)\n\nCreates a market depth chart to analyze supply and demand dynamics. The red area on the left represents the reversed cumulative distribution for bids. The blue area on the right represents the cumulative distribution for asks.  The mid market price is represented by vertical black line.\n\nArguments\n\norder_book::Vector{Order}: a vector of orders (bids and asks) representing the order book (i.e. outstanding orders)\n\nKeywords\n\nconfig...: optional keyword arguments to the function plot\n\n\n\n\n\n","category":"function"},{"location":"api/#ABMPredictionMarkets.plot_dashboard","page":"API","title":"ABMPredictionMarkets.plot_dashboard","text":"plot_dashboard(\n    model;\n    title = make_title(model.market_prices),\n    size = (1200, 1000),\n    depth_chart_layout = make_layout(model.market_prices),\n    outer_layout = [\n        (label = :a, width = :auto, height = 0.70),\n        (label = :b, width = :auto, height = 0.30)\n    ],\n    add_unpacking_factor = false,\n    n_days = 1,\n    depth_chart_config = (),\n    price_chart_config = (),\n)\n\nPlots an animated dashboard containing the following:\n\nA depth chart for each market. \nHistorical price for each market.\nOptional unpacking factor based on two market sets. \n\nArguments\n\nmodel: an abm object for the prediction market simulation \n\nKeywords\n\ntitle: a 1×n vector of labels for each market. By default, each element is eᵢ\ndepth_chart_layout: the layout of the depth charts. By default, the smallest possible 2D grid is used.\nsize = (1200, 1000): size of dashboard animation \nouter_layout: the layout for the dashboard\nadd_unpacking_factor = false: includes unpacking factor plot if true. If set to true, default layouts will need to be overwritten.\nn_days = 1: the number of days to simulate the prediction market\ndepth_chart_config = (): optional keyword arguments for the depth charts\nprice_chart_config = (): optional keyword arguments for price charts\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Functions","page":"API","title":"Internal Functions","text":"","category":"section"},{"location":"api/#ABMPredictionMarkets.add_shares!-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.add_shares!","text":"add_shares!(shares, share)\n\nAdds a share to a vector of shares. A new element is add if the shares do not have an entry with the target price.  If an entry with the target price exists, the quantity is added to that entry \n\nArguments\n\nshares: a vector of current shares \nshare: a share to be added to shares\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.ask-Tuple{Any, MarketAgent, AbstractCDA, Any, Any}","page":"API","title":"ABMPredictionMarkets.ask","text":"ask(agent, ::MarketAgent, ::AbstractCDA, model, bidx)\n\nGenerates an ask amount according to \n\nv ~ Uniform(p, + 1, p + δ),\n\nwhere p is the maximum share price. \n\nArguments\n\nagent: an agent participating in the prediction market\n::MarketAgent: variant of agent possibly of the same type as agent\n::AbstractPredictionMarket: a prediction market type \nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.ask_bid_match!-NTuple{4, Any}","page":"API","title":"ABMPredictionMarkets.ask_bid_match!","text":"ask_bid_match!(proposal, model, bidx, i)\n\nFor agent i and agent j, let b be the bid amount, a be the ask amount, and e be the event.    If bₑᵢ = aₑⱼ, then exchange. \n\nArgument\n\nproposal: a proposal bid or ask \nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\ni: the index for the current entry of the order book \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.ask_match!-NTuple{4, Any}","page":"API","title":"ABMPredictionMarkets.ask_match!","text":"ask_match!(proposal, model, bidx, i)\n\nFor agent i and agent j, let a be the ask amount, and e be the event.    If aₑᵢ + a¬ₑⱼ = 1, then remove shares and deduct ask amounts for i and j . \n\nArgument\n\nproposal: a proposal bid\nmodel: an abm object for the prediction market simulation \ni: the index for the current entry of the order book \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.bid-Tuple{Any, MarketAgent, AbstractCDA, Any, Any}","page":"API","title":"ABMPredictionMarkets.bid","text":"bid(agent, ::MarketAgent, ::AbstractCDA, model, bidx)\n\nGenerates an ask amount according to \n\nv ~ Uniform(p - δ, p - 1),\n\nwhere p is the agent's subject probability of the event, expressed on a scale ranging from 0 100 (cents). The bid price is subtracted from  money and added to the bid reserve to ensure the agent has sufficient funds when making bids  in multiple markets. \n\nArguments\n\nagent: an agent participating in the prediction market\n::MarketAgent: variant of agent possibly of the same type as agent\n::AbstractPredictionMarket: a prediction market type \nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.bid_match!-NTuple{4, Any}","page":"API","title":"ABMPredictionMarkets.bid_match!","text":"bid_match!(proposal, model, bidx, i)\n\nFor agent i and agent j, let b be the bid amount, and e be the event.    If bₑᵢ + b¬ₑⱼ = 1, then create new shares for i and j. \n\nArgument\n\nproposal: a proposal bid\nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\ni: the index for the current entry of the order book \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.compute_optimal_purchase-Tuple{Any, CPMM, Any, Any, Bool}","page":"API","title":"ABMPredictionMarkets.compute_optimal_purchase","text":"compute_optimal_purchase(agent, market::CPMM, belief, midx, yes)\n\nComputes the optimal amount of money to spend on shares based on a logarithmic utility function. \n\nArguments\n\nmarket::AbstractCPMM: an abstract constant product market maker object \ncost: the total cost of the shares\nmidx: market index\nyes::Bool: corresponds to a yes share if true; otherwise, corresponds to a no share\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.compute_price-Tuple{AbstractCPMM, Any, Bool}","page":"API","title":"ABMPredictionMarkets.compute_price","text":"compute_price(market::AbstractCPMM, midx, yes::Bool)\n\nReturns the current price of the specified share. \n\nArguments\n\nmarket::AbstractCPMM: an abstract constant product market maker object \nmidx: market index\nyes::Bool: corresponds to a yes share if true; otherwise, corresponds to a no share\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.compute_returns-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.compute_returns","text":"compute_returns(shares, p_true)\n\nComputes the expected return of a vector of shares. \n\nArguments\n\nshares: a vector of shares \np_true: the true probability of the event \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.cost_to_price-Tuple{AbstractLSR, Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.cost_to_price","text":"cost_to_price(cost, price, elasticity)\n\nFinds the total cost of a transaction to move the current price to a new price. \n\nArguments\n\ncost: the total dollar amount of an exchange of shares\nprice: the current price of a given share\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.cost_to_shares-Tuple{AbstractCPMM, Any, Any, Bool}","page":"API","title":"ABMPredictionMarkets.cost_to_shares","text":"cost_to_shares(market::AbstractCPMM, cost, midx)\n\nComputes the number of shares required to achieve a given cost. \n\nArguments\n\nmarket::AbstractCPMM: an abstract constant product market maker object \ncost: the total cost of the shares\nmidx: market index\nyes::Bool: corresponds to a yes share if true; otherwise, corresponds to a no share\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.cost_to_shares-Tuple{AbstractLSR, Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.cost_to_shares","text":"cost_to_shares(cost, price, elasticity)\n\nFinds the number of shares that can be purchased at a given total cost. \n\nArguments\n\ncost: the toal dollar amount of an exchange of shares\nprice: the current price of a given share\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.create_order-Tuple{Any, MarketAgent, AbstractCDA, Any, Any}","page":"API","title":"ABMPredictionMarkets.create_order","text":"create_order(agent, ::MarketAgent, ::AbstractCDA, model, bidx)\n\nCreates and returns a bid or ask. The function bid is called if the agent has no shares. The function ask is called if the agent has no money. If the agent has money and shares, bid and ask are called with equal probability. \n\nArguments\n\nagent::MarketAgent: an agent participating in the prediction market\n::MarketAgent: variant of agent possibly of the same type as agent\n::AbstractPredictionMarket: a prediction market type \nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.get_market_info-Tuple{Any}","page":"API","title":"ABMPredictionMarkets.get_market_info","text":"get_market_info(order_book; yes)\n\nReturns the maximum bid and minimum ask in the order book. \n\nArguments\n\norder_book: a vector of outstanding orders\n\nKeywords\n\nyes: returns maximum bid and minimum ask for yes orders if true \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.get_reserves-Tuple{AbstractCPMM, Any}","page":"API","title":"ABMPredictionMarkets.get_reserves","text":"get_reserves(market::AbstractCPMM, midx)\n\nReturns the liquidity reserves for a given market.\n\nArguments\n\nmarket::AbstractCPMM: an abstract constant product market maker object \nmidx: market index\n\nReturns\n\nreserves::Tuple: yes reserves, no reserves\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.price_to_cost-Tuple{AbstractCPMM, Any, Any, Bool}","page":"API","title":"ABMPredictionMarkets.price_to_cost","text":"price_to_cost(market::AbstractCPMM, target_price, midx, yes::Bool)\n\nComputes the total cost required to achieve a target price. \n\nArguments\n\nmarket::AbstractCPMM: an abstract constant product market maker object \ntarget_price: the desired price after transaction\nmidx: market index\nyes::Bool: corresponds to a yes share if true; otherwise, corresponds to a no share\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.price_to_cost-Tuple{AbstractLSR, Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.price_to_cost","text":"price_to_cost(target_price, price, elasticity)\n\nFinds the number of shares needed to change to a new price. \n\nArguments\n\ntarget_price: the new price after purchacing shares\nprice: the current price of a given share\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.price_to_shares-Tuple{AbstractLSR, Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.price_to_shares","text":"price_to_shares(target_price, price, elasticity)\n\nFinds the number of shares needed to change to a new price. \n\nArguments\n\ntarget_price: the new price after purchacing shares\nprice: the current price of a given share\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.remove_orders!-Tuple{MarketAgent, Any, Any}","page":"API","title":"ABMPredictionMarkets.remove_orders!","text":" remove_orders!(agent::MarketAgent, model, bidx)\n\nRemoves orders from the specified order book and transfers funds from the bid reserve to the agent's money fund.     \n\nArguments\n\nagent::MarketAgent: an agent participating in the prediction market\nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.sample_ask-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.sample_ask","text":"sample_ask(p, δ)\n\nSamples an amount to ask.  \n\nv ~ Uniform(p, + 1, p + δ),\n\nwhere p is typically the maximum share price. \n\nArguments\n\np: is typically the maximum share price. p ∈ [0, 100]\nδ: the range of noise added to ask price. δ ≥ 1.  \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.sample_bid-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.sample_bid","text":"sample_bid(judgment, δ)\n\nSamples an amount to ask.  \n\nv ~ Uniform(judgment, - δ, judgment - 1),\n\nwhere judgment is the agent's subjective probability. \n\nArguments\n\njudgment: s the agent's subjective probability. judgment ∈ [0, 100]\nδ: the range of noise added to ask price. δ ≥ 1.  \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.set_elasticity-Tuple{Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.set_elasticity","text":"set_elasticity(total_money, n_events, upper_price)\n\nSets the elasticity parameter to a value such that an upper price is achieved if all money      in a market allocated to a given event. \n\nArguments\n\ntotal_money: total money in a given market across all participants \nn_events: the number of events that can be purchased in a given market\nupper_price: the maximum price, achieved if all money is placed on a single event\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.shares_to_cost-Tuple{AbstractCPMM, Any, Any, Bool}","page":"API","title":"ABMPredictionMarkets.shares_to_cost","text":"shares_to_cost(market::AbstractCPMM, n_shares, midx)\n\nComputes the total cost associated with a given number of shares of shares. \n\nArguments\n\nmarket::AbstractCPMM: an abstract constant product market maker object \nn_shares: the number of shares\nmidx: market index\nyes::Bool: corresponds to a yes share if true; otherwise, corresponds to a no share\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.shares_to_cost-Tuple{AbstractLSR, Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.shares_to_cost","text":"shares_to_cost(price, n_shares, elasticity)\n\nFinds the cost given a number of shares and current price. \n\nArguments\n\nprice: the current price of a given share\nn_shares: the number of shares purchased\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.shares_to_price-Tuple{AbstractLSR, Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.shares_to_price","text":"shares_to_price(price, n_shares, elasticity)\n\nFinds the new price given a number of shares and current price. \n\nArguments\n\nprice: the current price of a given share\nn_shares: the number of shares purchased\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.to_beta-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.to_beta","text":"to_beta(μ, σ)\n\nReturns α and β parameters of beta distribution corresponding to the desired mean and  standard deviation. \n\nArguments\n\nμ: the desired mean of the beta distribution \nσ: the desired standard deviation of the beta distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.transact!-Tuple{Any, AbstractCDA, Any, Any}","page":"API","title":"ABMPredictionMarkets.transact!","text":"transact!(proposal, ::AbstractCDA, model, bidx)\n\nAttempts to find a possible trade for a submitted proposal (bid or ask). Returns true if the proposal trade was performed. Otherwise, false is returned. If the proposed trade is not completed, the proposal is added to  the order book.\n\nArguments\n\nproposal: a proposal bid or ask \n::AbstractCDA: a double continuous auction prediction market\nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.update_reserves!-Tuple{AbstractCPMM, Any, Any, Any, Bool}","page":"API","title":"ABMPredictionMarkets.update_reserves!","text":"update_reserves!(market::AbstractCPMM, n_shares, cost, midx, yes::Bool)\n\nUpdates the reserves given a transaction with a specified number of shares and total cost. \n\nArguments\n\nmarket::AbstractCPMM: an abstract constant product market maker object \nn_shares: the number of shares\ncost: the total cost of the shares\nmidx: market index\nyes::Bool: corresponds to a yes share if true; otherwise, corresponds to a no share\n\n\n\n\n\n","category":"method"},{"location":"arbitrage_example/#Arbitrage-Example","page":"Arbitrage Example","title":"Arbitrage Example","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"The purpose of this tutorial is to demonstrate how to simulate arbitrage in a set of prediction markets. The example below consists of two agent types: ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"subadditive agent: an agent whose beliefs about a set of prediction markets are subadditive (i.e., exceeds 1), and thus violate probability theory.\narbitrage agent: an agent who exploits subadditive markets by purchasing no shares in each market.","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Our example will demonstrate the value of arbitrage in correcting prices by comparing two conditions: (1) a no arbitrage condition consisting of 100 subadditive agents and zero arbitrage agents, and (2) an arbitrage condition consisting of 70 subadditive agents and 30 arbitrage agents. In the arbigtrage condition, the arbitrage agents will reduce subadditivity by renormalizing the market prices. ","category":"page"},{"location":"arbitrage_example/#Sub-Additivity","page":"Arbitrage Example","title":"Sub-Additivity","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"In this section, we provide a more formal explanation of subadditivity. Suppose the sample space boldsymbolOmega is partitioned into a set of mutually exclusive and exhaustive sub-events: boldsymbolOmega = e_1e_2 dots e_n. According to probability theory, the probabilities must be additive:  ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"p(e_1 cup e_2 cup dots cup e_n) = sum_e_i in boldsymbolOmega p(e_i) = 1","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"In other words, the sum of the probabilities across all sub-events must sum to 1. This logic extends to prediction markets because the market price is interpreted as a crowd sourced probability estimate.  Below, we will create a set of binary prediction markets covering events in boldsymbolOmega: ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"mathbfM = (e_1 bare_1)(e_2 bare_2) dots (e_n bare_n)","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Each market consists of and event e_i represented by yes shares and its complementary event bare_i represented by no shares. If additivity is satisfied, the sum of yes prices should approximate 1 at each time point. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Click on the ▶ icon to reveal a full version of the code.  ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"<details>\n<summary><b>Full Code</b></summary>","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: get_market\nusing ABMPredictionMarkets: get_min_ask\nusing ABMPredictionMarkets: init\nusing ABMPredictionMarkets: transact!\nusing Agents\nusing Plots\nusing Random\nusing Statistics\nimport ABMPredictionMarkets: agent_step!\n\n@agent struct SubadditiveAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Int}\n    δ::Int\n    money::Int\n    bid_reserve::Int\n    max_quantity::Int\n    shares::Vector{Vector{Order}}\nend\n\n@agent struct ArbitrageAgent(NoSpaceAgent) <: MarketAgent\n    money::Int\n    bid_reserve::Int\n    shares::Vector{Vector{Order}}\nend\n\n\n@multiagent MultiAgent(ArbitrageAgent, SubadditiveAgent) <: MarketAgent\n\nfunction agent_step!(agent, ::ArbitrageAgent, ::AbstractPredictionMarket, model)\n    no_prices = get_no_prices(model)\n    cost, win = eval_arbitrage(no_prices, 0)\n    if (cost < win) && (agent.money ≥ cost)\n        for bidx ∈ 1:length(model.order_books)\n            price = no_prices[bidx]\n            agent.bid_reserve += price\n            agent.money -= price\n            order = Order(;id = agent.id, yes = false, price, quantity = 1, type = :bid)\n            transact!(order, model, bidx)\n        end\n    else\n        for bidx ∈ 1:length(model.order_books) \n            push!(model.trade_volume[bidx], 0)\n            push!(model.iteration_ids[bidx], abmtime(model))\n            market_prices = model.market_prices[bidx]\n            isempty(market_prices) ? push!(market_prices, NaN) :\n            push!(market_prices, market_prices[end])\n        end\n    end\n    return nothing\nend\n\nfunction eval_arbitrage(no_prices, fee_percent)\n    n_win = length(no_prices) - 1\n    win = n_win * 100\n    cost = sum(no_prices)\n    fees = sum(compute_fee.(fee_percent, sort(no_prices[1:n_win])))\n    return (;cost, win = win - fees)\nend\n\ncompute_fee(fee_percent, price) = fee_percent * min(price, 100 - price) * (100 / price)\n\nfunction get_no_prices(model)\n    return get_min_ask.(model.order_books; yes = false)\nend\n\nfunction initialize(\n    standard_type::Type{<:SubadditiveAgent},\n    arbitrage_type::Type{<:ArbitrageAgent};\n    n_subadditive,\n    n_arbitrage,\n    μ,\n    η,\n    δ,\n    money,\n    max_quantity = 1,\n    unpacking_factor,\n)\n    space = nothing\n    n_markets = length(μ)\n    model = StandardABM(\n        MultiAgent,\n        space;\n        properties = CDA(; n_markets),\n        agent_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    id = 0\n    for _ ∈ 1:n_subadditive\n        id += 1\n        judgments = Int.(round.(rand(DiscreteDirichlet(μ, η)) * unpacking_factor))\n        agent = (MultiAgent ∘ standard_type)(;\n            id,\n            judgments,\n            money,\n            bid_reserve = 0,\n            δ,\n            max_quantity,\n            shares = init(Order, n_markets)\n        )\n        add_agent!(agent, model)\n    end\n    for _ ∈ 1:n_arbitrage\n        id += 1\n        agent = (MultiAgent ∘ arbitrage_type)(;\n            id,\n            money,\n            bid_reserve = 0,\n            shares = init(Order, n_markets)\n        )\n        add_agent!(agent, model)\n    end\n    return model\nend\n\nRandom.seed!(5064)\n\nconfig = (\n    μ = [0.45, 0.20, 0.25, 0.10],\n    η = 20.0,\n    unpacking_factor = 1.3,\n    δ = 3,\n    money = 5000,\n    max_quantity = 1,\n)\n\nno_arbitrage_model = initialize(\n    SubadditiveAgent,\n    ArbitrageAgent;\n    n_subadditive = 100,\n    n_arbitrage = 0,\n    config...\n)\n\narbitrage_model = initialize(\n    SubadditiveAgent,\n    ArbitrageAgent;\n    n_subadditive = 70,\n    n_arbitrage = 30,\n    config...\n)\n\nrun!(no_arbitrage_model, 100)\nrun!(arbitrage_model, 100)\n\nno_arbitrage_market_prices = summarize_by_iteration.(no_arbitrage_model.market_prices, no_arbitrage_model.iteration_ids)\n\nplot(\n    sum(no_arbitrage_market_prices),\n    ylims = (0, 2),\n    xlabel = \"Day\", \n    ylabel = \"Unpacking Factor\",\n    grid = false,\n    label = \"No Arbitriage\",\n)\nhline!([1], color = :black, linestyle = :dash, label = nothing)\n\narbitrage_market_prices = summarize_by_iteration.(arbitrage_model.market_prices, arbitrage_model.iteration_ids)\nplot!(sum(arbitrage_market_prices), label = \"Arbitriage\")","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"</details>","category":"page"},{"location":"arbitrage_example/#Load-Dependencies","page":"Arbitrage Example","title":"Load Dependencies","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Our first step is to load the required dependencies for simulation and plotting. In addition, we will import the function agent_step! so we can create a new method defining the behavior of the subadditive agent. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: get_market\nusing ABMPredictionMarkets: get_min_ask\nusing ABMPredictionMarkets: init\nusing ABMPredictionMarkets: transact!\nusing Agents\nusing Plots\nusing Random\nusing Statistics\nimport ABMPredictionMarkets: agent_step!","category":"page"},{"location":"arbitrage_example/#Define-Agents","page":"Arbitrage Example","title":"Define Agents","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Below, we define agent types which is are subtype of MarketAgent. ","category":"page"},{"location":"arbitrage_example/#Subadditive-Agents","page":"Arbitrage Example","title":"Subadditive Agents","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"As the name implies, the probability judgments of the subadditive agent are subadditive. The subadditive agent has the following fields:","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"judgments::Vector{Int}: a vector of probabilities for each event expressed in cents, which sum to a value greater than 100 because they are subadditive. \nδ::Int: the degree of variability in bids and asks expressed in cents. \nmoney::Int: the amount of money available to the agent expressed in cents. \nbid_reserve::Int: the amount of money reserved for bids in the order book for ensuring sufficient funds\nmax_quantity::Int the maximum quantity of shares per order\nshares::Vector{Vector{Order}}: a constaining for storing the shares owned by the agent. Each sub-vector corresponds to a shares for a sub-event. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"On each simulated day when the function agent_step! is called for a subadditive agent, it submits a bid or ask in each available market. Roughly speaking, it accepts the maximum bid or minimum ask if it is advantageous. Otherwise, it submits an order for an ask or bid with uniform variable and a range of delta cents. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"@agent struct SubadditiveAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Int}\n    δ::Int\n    money::Int\n    bid_reserve::Int\n    max_quantity::Int\n    shares::Vector{Vector{Order}}\nend","category":"page"},{"location":"arbitrage_example/#Arbitrage-Agent","page":"Arbitrage Example","title":"Arbitrage Agent","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"The goal of the arbitrage agent is to exploit sub-additive prices by purchacing no shares for all markets. Using this strategy guarantees a payout of 1 dollar for n-1 shares, i.e., all shares except the share whose complementary event occured. Assuming prices are sub-additive (i.e., sum_i=1^n e_i 1), then the cost of no shares for all markets, c,  must be less than the payout: c  n - 1. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"<details>\n<summary><b>Mathematical Details</b></summary>","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Below, we show that the cost c is less than the pay out n - 1:","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"c  n - 1","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"First, we define c as:","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"c = sum_i=1^n bare_i","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"In a binary market, bare_i = 1 - e_i. Substituting 1 - e_i into the equation results in:","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"c = sum_i=1^n 1 - e_i","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"The terms in the summation can be broken down into seperate summations of the same index set:","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"c = sum_i=1^n 1 - sum_i=1^n e_i","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Substitute sum_i=1^n 1 = n into the equation above, resulting in:","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"c = n - sum_i=1^n e_i","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Substituting n - sum_i=1^n e_i into c  n-1, we have","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"n - sum_i=1^n e_i  n - 1","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Subtract n from both sides:","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"sum_i=1^n e_i  1","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"which is consistent with our assumption of sub-additivity.","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"</details>","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"The arbitrage agent has a subset of fields defined above for the subadditive agent. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"@agent struct ArbitrageAgent(NoSpaceAgent) <: MarketAgent\n    money::Int\n    bid_reserve::Int\n    shares::Vector{Vector{Order}}\nend","category":"page"},{"location":"arbitrage_example/#Multi-Agent","page":"Arbitrage Example","title":"Multi-Agent","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"To improve performance, we will wrap the two agent types into a MultiAgent type with the @multiagent macro.","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"@multiagent MultiAgent(ArbitrageAgent, SubadditiveAgent) <: MarketAgent","category":"page"},{"location":"arbitrage_example/#Agent-Step-Function","page":"Arbitrage Example","title":"Agent Step Function","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"The behavior of the arbitrage agent in the agent_step! method below. The function works as follows. First, the agent determines whether it can exploit subadditive prices. Second, if it can, it submits an order for a no share in each market. Otherwise, it records the previous market price as the current market price. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"function agent_step!(agent, ::ArbitrageAgent, ::AbstractPredictionMarket, model)\n    no_prices = get_no_prices(model)\n    cost, win = eval_arbitrage(no_prices, 0)\n    if (cost < win) && (agent.money ≥ cost)\n        for bidx ∈ 1:length(model.order_books)\n            price = no_prices[bidx]\n            agent.bid_reserve += price\n            agent.money -= price\n            order = Order(;id = agent.id, yes = false, price, quantity = 1, type = :bid)\n            transact!(order, model, bidx)\n        end\n    else\n        for bidx ∈ 1:length(model.order_books) \n            push!(model.trade_volume[bidx], 0)\n            push!(model.iteration_ids[bidx], abmtime(model))\n            market_prices = model.market_prices[bidx]\n            isempty(market_prices) ? push!(market_prices, NaN) :\n            push!(market_prices, market_prices[end])\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"arbitrage_example/#Arbitrage-Functions","page":"Arbitrage Example","title":"Arbitrage Functions","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"The code block defines three helper functions for arbitrage. Given a vector of no prices and a free percent, the function eval_arbitrage returns the cost and the payout for buying no shares in each prediction market. The function compute_fee returns the fees Polymarket applies to winnings. In our example, we assume for simplicity that the fee is zero percent. Finally, the function get_all_no_prices returns a vector of asking prices for no shares in each market. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"function eval_arbitrage(no_prices, fee_percent)\n    n_win = length(no_prices) - 1\n    win = n_win * 100\n    cost = sum(no_prices)\n    fees = sum(compute_fee.(fee_percent, sort(no_prices[1:n_win])))\n    return (;cost, win = win - fees)\nend\n\ncompute_fee(fee_percent, price) = fee_percent * min(price, 100 - price) * (100 / price)\n\nfunction get_no_prices(model)\n    return get_min_ask.(model.order_books; yes = false)\nend","category":"page"},{"location":"arbitrage_example/#Model-Initialization-Function","page":"Arbitrage Example","title":"Model Initialization Function","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"In the code block below, we define a function that initializes the model and adds agents to the newly created model. The model has no spatial component because agents do not need to move in their environment. The model uses a type of prediction market called a continuous double action (see the type CDA). In addition, the scheduler randomizes the order in each agents perform their actions on each day. The function requires the following keyword arguments:","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"n_subadditive: the number of subadditive agents in the simulation\nn_arbitrage: the number of arbitrage agents in the simulation\nμ: the mean probability judgments sampled from a Dirichlet distribution\nη: the precession of probability judgments sampled from a Dirichlet distribution\nδ::Int: the degree of variability in bids and asks expressed in cents. \nmoney: the initial amount of money given to each agent\nmax_quantity = 1: the maximum number of shares per order for each agent per day\nunpacking_factor: controls the degree of subadditivity in the judgments of the subadditive agents","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"function initialize(\n    standard_type::Type{<:SubadditiveAgent},\n    arbitrage_type::Type{<:ArbitrageAgent};\n    n_subadditive,\n    n_arbitrage,\n    μ,\n    η,\n    δ,\n    money,\n    max_quantity = 1,\n    unpacking_factor,\n)\n    space = nothing\n    n_markets = length(μ)\n    model = StandardABM(\n        MultiAgent,\n        space;\n        properties = CDA(; n_markets),\n        agent_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    id = 0\n    for _ ∈ 1:n_subadditive\n        id += 1\n        judgments = Int.(round.(rand(DiscreteDirichlet(μ, η)) * unpacking_factor))\n        agent = (MultiAgent ∘ standard_type)(;\n            id,\n            judgments,\n            money,\n            bid_reserve = 0,\n            δ,\n            max_quantity,\n            shares = init(Order, n_markets)\n        )\n        add_agent!(agent, model)\n    end\n    for _ ∈ 1:n_arbitrage\n        id += 1\n        agent = (MultiAgent ∘ arbitrage_type)(;\n            id,\n            money,\n            bid_reserve = 0,\n            shares = init(Order, n_markets)\n        )\n        add_agent!(agent, model)\n    end\n    return model\nend","category":"page"},{"location":"arbitrage_example/#Set-RNG-Seed","page":"Arbitrage Example","title":"Set RNG Seed","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"The next code block sets the seed for the random number generator to ensure the results are reproducible. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"Random.seed!(5064)","category":"page"},{"location":"arbitrage_example/#Initialize-Models","page":"Arbitrage Example","title":"Initialize Models","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"In this section, we create models for the no arbitrage condition and the arbitrage condition with the function called initialize. The code block below defines a NamedTuple of the common parameters for each model. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"config = (\n    μ = [0.45, 0.20, 0.25, 0.10],\n    η = 20.0,\n    unpacking_factor = 1.3,\n    δ = 3,\n    money = 5000,\n    max_quantity = 1,\n)","category":"page"},{"location":"arbitrage_example/#No-Arbitrage-Model","page":"Arbitrage Example","title":"No Arbitrage Model","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"The defining feature of the no arbitrage model is the absence of arbitrage agents. Specifically, we set the number of subadditive agents to 100 and the number of arbitrage agents to 0. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"no_arbitrage_model = initialize(\n    SubadditiveAgent,\n    ArbitrageAgent;\n    n_subadditive = 100,\n    n_arbitrage = 0,\n    config...\n)","category":"page"},{"location":"arbitrage_example/#Arbitrage-Model","page":"Arbitrage Example","title":"Arbitrage Model","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"By contrast, the arbitrage model does include arbitrage agents. Specifically, we set the number of subadditive agents to 70 and the number of arbitrage agents to 30. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"arbitrage_model = initialize(\n    SubadditiveAgent,\n    ArbitrageAgent;\n    n_subadditive = 70,\n    n_arbitrage = 30,\n    config...\n)","category":"page"},{"location":"arbitrage_example/#Run-Models","page":"Arbitrage Example","title":"Run Models","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"In the code block below, we run each model for 100 days. Agents sequentially perform their actions in a different random order each day. ","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"run!(no_arbitrage_model, 100)\nrun!(arbitrage_model, 100)","category":"page"},{"location":"arbitrage_example/#Plot-Results","page":"Arbitrage Example","title":"Plot Results","text":"","category":"section"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"In the plot below, we plot the ending market price each day for the no arbitrage and arbitrage models. As expected, both models show evidence of subadditivity (i.e., the data points are above 1), but the degree of subadditivity is less pronounced in the arbitrage model, indicating arbitrage agents were able to exploit the mispriced markets and partially correct the prices.","category":"page"},{"location":"arbitrage_example/","page":"Arbitrage Example","title":"Arbitrage Example","text":"no_arbitrage_market_prices = summarize_by_iteration.(no_arbitrage_model.market_prices, no_arbitrage_model.iteration_ids)\nplot(\n    sum(no_arbitrage_market_prices),\n    ylims = (0, 2),\n    xlabel = \"Day\", \n    ylabel = \"Unpacking Factor\",\n    grid = false,\n    label = \"No Arbitriage\",\n)\nhline!([1], color = :black, linestyle = :dash, label = nothing)\narbitrage_market_prices = summarize_by_iteration.(arbitrage_model.market_prices, arbitrage_model.iteration_ids)\nplot!(sum(arbitrage_market_prices), label = \"Arbitriage\")","category":"page"},{"location":"price_manipulation_example/#Price-Manipulation-Example","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"Our goal in this example is to develop an agent based model of price manipulation in a prediction market as described in the arXiv paper entitled How manipulable are prediction markets? (Rasooly & Rozzi, 2025). In this example, a small set of agents trade shares in a prediction market based on a constant product market maker. During the trading period, a manipulator increases the current market price by .05 units. The model illustrates partial recovery of the market price, similar to what was found empirically in a large scale field experiment conducted by the authors (Rasooly & Rozzi, 2025).","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"If you prefer to skip the explanation below, click on the ▶ icon to reveal a full version of the code.  ","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"<details>\n<summary><b>Full Code</b></summary>","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: compute_optimal_purchase\nusing ABMPredictionMarkets: compute_price\nusing ABMPredictionMarkets: cost_to_shares\nusing ABMPredictionMarkets: get_market\nusing ABMPredictionMarkets: init\nusing ABMPredictionMarkets: price_to_cost\nusing ABMPredictionMarkets: shares_to_cost\nusing ABMPredictionMarkets: update_reserves!\nusing ABMPredictionMarkets: transact!\nusing Agents\nusing Distributions\nusing Plots\nusing Random\nusing Revise\nimport ABMPredictionMarkets: agent_step!\n\n@agent struct CPMMAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Vector{Float64}}\n    money::Float64\n    shares::Vector{Vector{Float64}}\n    λ::Float64\nend\n\nfunction model_step!(model)\n    agent = random_agent(model)\n    agent_step!(agent, model)\n    if abmtime(model) ∈ model.times\n        market = get_market(model)\n        current_price = compute_price(market, 1, true)\n        target_price = min(1, current_price + 0.05)\n        cost = price_to_cost(market, target_price, 1, true)\n        n_shares = cost_to_shares(market, cost, 1, true)\n        update_reserves!(market, n_shares, cost, 1, true)\n        push!(model.trade_volume[1], n_shares)\n        push!(model.market_prices[1], compute_price(market, 1, true))\n    end\n    return nothing\nend\n\nfunction agent_step!(agent, ::CPMMAgent, market::AbstractCPMM, model)\n    (; judgments, λ) = agent\n    if agent.shares[1][1] > 0\n        # sell yes shares\n        n_shares = -agent.shares[1][1]\n        cost = shares_to_cost(market, n_shares, 1, true)\n        order = AMMOrder(; id = agent.id, option = true, cost, n_shares)\n        transact!(order, market, model, 1)\n        pop!(model.trade_volume[1])\n        pop!(model.market_prices[1])\n    end\n    if agent.shares[1][2] > 0\n        # sell no shares\n        n_shares = -agent.shares[1][2]\n        cost = shares_to_cost(market, n_shares, 1, false)\n        order = AMMOrder(; id = agent.id, option = false, cost, n_shares)\n        transact!(order, market, model, 1)\n        pop!(model.trade_volume[1])\n        pop!(model.market_prices[1])\n    end\n\n    price = compute_price(market, 1, true)\n    belief = (1 - λ) * judgments[1][1] + λ * price\n    if belief ≥ price\n        # buy yes shares\n        cost = compute_optimal_purchase(agent, market, belief, 1, true)\n        n_shares = cost_to_shares(market, cost, 1, true)\n        order = AMMOrder(; id = agent.id, option = true, cost, n_shares)\n        transact!(order, market, model, 1)\n    elseif belief < price\n        # buy no shares\n        cost = compute_optimal_purchase(agent, market, belief, 1, false)\n        n_shares = cost_to_shares(market, cost, 1, false)\n        order = AMMOrder(; id = agent.id, option = false, cost, n_shares)\n        transact!(order, market, model, 1)\n    end\n    return nothing\nend\n\nfunction initialize(\n    agent_type::Type{<:CPMMAgent};\n    n_agents,\n    λ,\n    money,\n    yes_reserves,\n    no_reserves,\n    manipulate_time\n)\n    yes_reserves = deepcopy(yes_reserves)\n    no_reserves = deepcopy(no_reserves)\n    space = nothing\n    model = StandardABM(\n        agent_type,\n        space;\n        properties = CPMM(; yes_reserves, no_reserves, times = [manipulate_time]),\n        model_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    for i ∈ 1:n_agents\n        p = (i - 1) / (n_agents - 1)\n        judgments = [[p, 1-p]]\n        add_agent!(\n            model;\n            judgments,\n            money,\n            λ,\n            shares = [zeros(2)]\n        )\n    end\n    return model\nend\n\nconfig = (\n    n_agents = 11,\n    λ = 0.0,\n    money = 100,\n    no_reserves = [1000.0],\n    yes_reserves = [1000.0],\n    manipulate_time = 100,\n)\n\nmarket_prices = map(1:1000) do _\n    model = initialize(CPMMAgent; config...)\n    run!(model, 200)\n    model.market_prices[1]\nend\n\nplot(\n    mean(market_prices),\n    ylims = (.4, .6),\n    xlabel = \"Day\",\n    ylabel = \"Price of Yes Share\",\n    linewidth = 2.5,\n    grid = false,\n    leg = false,\n)\nhline!([.5], color = :black, linestyle = :dash)","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"</details>","category":"page"},{"location":"price_manipulation_example/#Load-Dependencies","page":"Price Manipulation Example","title":"Load Dependencies","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"Our first step is to load the required dependencies for simulation and plotting. In addition, we will import the function agent_step! so we can create a new method defining the behavior of the agents in the price manipulation simulation.","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: compute_optimal_purchase\nusing ABMPredictionMarkets: compute_price\nusing ABMPredictionMarkets: cost_to_shares\nusing ABMPredictionMarkets: get_market\nusing ABMPredictionMarkets: init\nusing ABMPredictionMarkets: price_to_cost\nusing ABMPredictionMarkets: shares_to_cost\nusing ABMPredictionMarkets: update_reserves!\nusing ABMPredictionMarkets: transact!\nusing Agents\nusing Distributions\nusing Plots\nusing Random\nusing Revise\nimport ABMPredictionMarkets: agent_step!","category":"page"},{"location":"price_manipulation_example/#CPMM-Agent","page":"Price Manipulation Example","title":"CPMM Agent","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"The code block below defines an agent type called CPMMAgent. In this agent type, the first three fields are required, and the fourth field is an optional parameter included for this specific simulation scenario. The fields are defined as follows:","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"judgements: a vector of vectors in which elements of the outer vector represent individual prediction markets and elements of the inner vectors represent subjective price estimates of options of a given market. For example judgements = [[.3,.7],[.2,.8]] contains price estimates for two prediction markets and [.3,.7] represents the price estimates of the first and second options of the first prediction market. Currently, CPMM only supports binary prediction markets, but multiple prediction markets may be used within the same simulation. \nmoney: the amount of money in dollars available to purchase shares.\nshares: a vector of vectors recording the number of shares the agent owns. Similar to the field judgments elements of the outer vector represent individual prediction markets and elements of inner vector represent different options within a prediction market. \nλ: the weight given to an estimated price in judgments relative to the current market place, such that lambda in left0 1 right.  ","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"@agent struct CPMMAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Vector{Float64}}\n    money::Float64\n    shares::Vector{Vector{Float64}}\n    λ::Float64\nend","category":"page"},{"location":"price_manipulation_example/#Constant-Product-Market-Maker","page":"Price Manipulation Example","title":"Constant Product Market Maker","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"The price manipulation simulation uses a type of prediction market called a constant product market maker (CPMM). A CPMM is a type of automated market maker which uses an algorithm ensure liquidity in a market and adjust the price of an asset based on demand. The price of a share in a CPMM is determined by the product of the amount of reserves for yes shares and no shares:","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"r_y cdot r_n = k","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"where r_y and r_n are the reserves for yes and no shares, respectively. Share prices are constrained such that the product of yes and no reserves must equal the constant k, as shown below:","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"<details>\n<summary><b>Plot Code</b></summary>","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"reserve_plot = let \n    x = .01:.01:250\n    y = 1000 ./ x \n    plot(x, y, xlabel = \"Yes Reserves\", ylabel = \"No Reserves\", lims = (0, 250), grid = false, leg = false)\nend\nnothing","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"</details>","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"reserve_plot","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"The price is computed as the ratio of reserves. For example, the price for a yes share is fracr_nr_y + r_n.","category":"page"},{"location":"price_manipulation_example/#Model-Step-Function","page":"Price Manipulation Example","title":"Model Step Function","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"On each iteration of the simulation, the function model_step! is called, which performs the following actions:","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"Select a random agent and trade via the agent_step! function.\nManipulate the current price by 05 units at specified iterations. ","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"function model_step!(model)\n    agent = random_agent(model)\n    agent_step!(agent, model)\n    if abmtime(model) ∈ model.times\n        market = get_market(model)\n        current_price = compute_price(market, 1, true)\n        target_price = min(1, current_price + 0.05)\n        cost = price_to_cost(market, target_price, 1, true)\n        n_shares = cost_to_shares(market, cost, 1, true)\n        update_reserves!(market, n_shares, cost, 1, true)\n        push!(model.trade_volume[1], n_shares)\n        push!(model.market_prices[1], compute_price(market, 1, true))\n    end\n    return nothing\nend","category":"page"},{"location":"price_manipulation_example/#Agent-Step-Function","page":"Price Manipulation Example","title":"Agent Step Function","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"The agent_step!, which is called in the model_step! function above, defines the trading behavior of the agents. agent_step! performs the following actions:","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"sell any available yes or no shares\ndefine belief b for price of yes shares as b = lambda cdot p + (1 - lambda) cdot j, where p is the current price of a yes share and j is the estimated price. Buy yes if b leq j, buy no otherwise.","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"function agent_step!(agent, ::CPMMAgent, market::AbstractCPMM, model)\n    (; judgments, λ) = agent\n    if agent.shares[1][1] > 0\n        # sell yes shares\n        n_shares = -agent.shares[1][1]\n        cost = shares_to_cost(market, n_shares, 1, true)\n        order = AMMOrder(; id = agent.id, option = true, cost, n_shares)\n        transact!(order, market, model, 1)\n        pop!(model.trade_volume[1])\n        pop!(model.market_prices[1])\n    end\n    if agent.shares[1][2] > 0\n        # sell no shares\n        n_shares = -agent.shares[1][2]\n        cost = shares_to_cost(market, n_shares, 1, false)\n        order = AMMOrder(; id = agent.id, option = false, cost, n_shares)\n        transact!(order, market, model, 1)\n        pop!(model.trade_volume[1])\n        pop!(model.market_prices[1])\n    end\n\n    price = compute_price(market, 1, true)\n    belief = (1 - λ) * judgments[1][1] + λ * price\n    if belief ≥ price\n        # buy yes shares\n        cost = compute_optimal_purchase(agent, market, belief, 1, true)\n        n_shares = cost_to_shares(market, cost, 1, true)\n        order = AMMOrder(; id = agent.id, option = true, cost, n_shares)\n        transact!(order, market, model, 1)\n    elseif belief < price\n        # buy no shares\n        cost = compute_optimal_purchase(agent, market, belief, 1, false)\n        n_shares = cost_to_shares(market, cost, 1, false)\n        order = AMMOrder(; id = agent.id, option = false, cost, n_shares)\n        transact!(order, market, model, 1)\n    end\n    return nothing\nend","category":"page"},{"location":"price_manipulation_example/#Model-Initialization-Function","page":"Price Manipulation Example","title":"Model Initialization Function","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"The function specified in the code block below initializes the model using parameter values provided by the user. The model contains agents and a CPMM without a spatial component. The keyword arguments for the function are defined as follows: ","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"agent_type: the agent type used in the simlation\nn_agents: the number of agents in the simulation\nλ: the price weight parameter\nmoney: the initial amount of money available for each agent to buy shares\nyes_reserves: the number of reserves for yes shares\nno_reserves: the number of reserves for no shares\nmanipulate_time: the time at which the market is manipulated","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"The estimated price ranges from 0 to 1 across agents, such that the average estimate is .50.","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"function initialize(\n    agent_type::Type{<:CPMMAgent};\n    n_agents,\n    λ,\n    money,\n    yes_reserves,\n    no_reserves,\n    manipulate_time\n)\n    yes_reserves = deepcopy(yes_reserves)\n    no_reserves = deepcopy(no_reserves)\n    space = nothing\n    model = StandardABM(\n        agent_type,\n        space;\n        properties = CPMM(; yes_reserves, no_reserves, times = [manipulate_time]),\n        model_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    for i ∈ 1:n_agents\n        p = (i - 1) / (n_agents - 1)\n        judgments = [[p, 1-p]]\n        add_agent!(\n            model;\n            judgments,\n            money,\n            λ,\n            shares = [zeros(2)]\n        )\n    end\n    return model\nend","category":"page"},{"location":"price_manipulation_example/#Set-RNG-Seed","page":"Price Manipulation Example","title":"Set RNG Seed","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"In the code block below, we set the seed for the random number generator to ensure reproducible results. ","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"Random.seed!(5471)","category":"page"},{"location":"price_manipulation_example/#Configure-Model","page":"Price Manipulation Example","title":"Configure Model","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"In the NamedTuple below, we will set the values for the keyword arguments passed to the initialize function. The parameter values were selected to reproduce Figure 1 (a) reported in Rasooly & Rozzi (2025). ","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"config = (\n    n_agents = 11,\n    λ = 0.0,\n    money = 100,\n    no_reserves = [1000.0],\n    yes_reserves = [1000.0],\n    manipulate_time = 100,\n)","category":"page"},{"location":"price_manipulation_example/#Simulate-the-Model","page":"Price Manipulation Example","title":"Simulate the Model","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"Now that we have defined the agents and the model parameters, we are in the position to simulate the model. The code below runs the model 1000 times and returns a vector of 200 market prices per run. ","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"market_prices = map(1:1000) do _\n    model = initialize(CPMMAgent; config...)\n    run!(model, 200)\n    model.market_prices[1]\nend","category":"page"},{"location":"price_manipulation_example/#Plot-the-Results","page":"Price Manipulation Example","title":"Plot the Results","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"The code block below plots the price as a function of time averaged across the 1000 simulations. The dashed line denotes the expected price based on the beliefs of the agents. At day 100, a manipulator inflates the price by 5 cents. The true price shows a gradual, but partial recovery, which suggests that price manipulation can have an enduring effect. ","category":"page"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"plot(\n    mean(market_prices),\n    ylims = (.39, .61),\n    xlabel = \"Day\",\n    ylabel = \"Price of Yes Share\",\n    linewidth = 2.5,\n    grid = false,\n    leg = false,\n)\nhline!([.5], color = :black, linestyle = :dash)","category":"page"},{"location":"price_manipulation_example/#References","page":"Price Manipulation Example","title":"References","text":"","category":"section"},{"location":"price_manipulation_example/","page":"Price Manipulation Example","title":"Price Manipulation Example","text":"Rasooly, I., & Rozzi, R. (2025). How manipulable are prediction markets?. arXiv preprint arXiv:2503.03312.","category":"page"},{"location":"#ABMPredictionMarkets","page":"Home","title":"ABMPredictionMarkets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides an API built upon the Agents.jl framework for creating agent-based models of prediction markets. The package provides support for the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Default methods for processing transactions\nThe ability to develop agents with custom behavior\nDifferent types of prediction markets, including continous double auctions and automated market makers\nPlotting and animations for time series, depth charts, autocorrelation, and trade volume charts","category":"page"},{"location":"","page":"Home","title":"Home","text":"The animation below shows depth charts and time series of four prediction markets. The depth charts show outstanding bids in red and asks in blue in the order book. When an ask price and bid price match, a transaction occurs and the resulting price is updated in the time series plot below. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details>\n<summary><b>Show Plotting Code </b></summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Random\nusing Agents\nusing Plots\nusing ABMPredictionMarkets\nRandom.seed!(568)\n\nn_agents = 200\nmodel = initialize(\n    TestAgent;\n    n_agents,\n    μ = [0.20, 0.25, 0.10, 0.45],\n    η = 20.0,\n    money = 50000,\n    δ = 3,\n    n_markets = 5\n)\n\nanimation = plot_dashboard(model)\ngif(animation, \"temp.gif\", fps = 8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/temp.gif\" width=1200 height=800>","category":"page"},{"location":"basic_example/#Basic-Example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The page provides a working example of simulating a prediction market with ABMPredictionMarkets.jl. In the example below, 100 agents trade shares in four prediction markets. The belief distributions across agents are distributed such that the sum of prices is approximately 1. Click on the ▶ icon to reveal a full version of the code.  ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"<details>\n<summary><b>Full Code</b></summary>","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: init\nusing Agents\nusing Distributions\nusing LaTeXStrings\nusing Plots\nusing Random\nusing StatsBase\nRandom.seed!(93)\n\n@agent struct TestAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Int}\n    δ::Int\n    money::Int\n    bid_reserve::Int\n    max_quantity::Int\n    shares::Vector{Vector{Order}}\nend\n\nimport ABMPredictionMarkets: initialize\nfunction initialize(\n    ::Type{<:TestAgent};\n    n_agents,\n    μ,\n    η,\n    δ,\n    money,\n    max_quantity = 1,\n)\n    space = nothing\n    n_markets = length(μ)\n    model = StandardABM(\n        TestAgent,\n        space;\n        properties = CDA(; n_markets),\n        agent_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    for _ ∈ 1:n_agents\n        add_agent!(\n            model;\n            judgments = rand(DiscreteDirichlet(μ, η)),\n            money,\n            bid_reserve = 0,\n            δ,\n            max_quantity,\n            shares = init(Order, n_markets)\n        )\n    end\n    return model\nend\n\nn_agents = 100\nμ = [0.20, 0.25, 0.10, 0.45]\nmodel = initialize(\n    TestAgent;\n    n_agents,\n    μ,\n    η = 20.0,\n    money = 10_000,\n    δ = 3\n)\nrun!(model, 50)\n\nmarket_titles = [L\"e_{1}\" L\"e_{2}\" L\"e_{3}\" L\"e_{4}\"]\nmarket_prices = summarize_by_iteration.(model.market_prices, model.iteration_ids)\nplot(\n    market_prices,\n    ylims = (0, 1),\n    ylabel = \"Market Price\",\n    grid = false,\n    legendtitle = \"Markets\",\n    label = market_titles\n)\nhline!(μ, color = :black, linestyle = :dash, label = nothing)\n\ntrade_volume = summarize_by_iteration.(model.trade_volume, model.iteration_ids; fun = sum)\n\nplot(\n    trade_volume;\n    layout = (2,2),\n    grid = false,\n    label = false,\n    title = market_titles,\n    ylims = (0, 100),\n    plot_title = \"Trade Volume\"\n)\n\ndepth_charts = plot_depth_chart.(model.order_books)\nplot(depth_charts...; layout = (2, 2), title = market_titles)\n\nautocors = @. (autocor(filter(x -> !isnan(x), model.market_prices)))\nplot(\n    autocors;\n    xlabel = \"lag\",\n    leg = false,\n    grid = false,\n    layout = (2, 2),\n    title = market_titles,\n    plot_title = \"Autocorrelation\"\n)\n\nmodel = initialize(\n    TestAgent;\n    n_agents,\n    μ,\n    η = 20.0,\n    money = 10_000,\n    δ = 3,\n    max_quantity = 5\n)\n\nanimation = plot_dashboard(model; n_days = 2)\ngif(animation, \"temp.gif\", fps = 8)","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"</details>","category":"page"},{"location":"basic_example/#Load-Dependencies","page":"Basic Example","title":"Load Dependencies","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The next step is to load the required dependencies for simulation and plotting.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: init\nusing Agents\nusing Distributions\nusing LaTeXStrings\nusing Plots\nusing Random\nusing StatsBase\nRandom.seed!(93)","category":"page"},{"location":"basic_example/#Define-Agent","page":"Basic Example","title":"Define Agent","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Below, we define an agent type which is a subtype of MarketAgent. The subjective judgments are stored in the field judgements for each market on a scale of 0 to 100 (e.g., cents). The money and bid reserve are also expressed in terms of cents. The maximum quantity is the maximum number of shares traded per day per agent. Finally, the field shares stores shares in separate sub-vectors for each market. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"@agent struct TestAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Int}\n    δ::Int\n    money::Int\n    bid_reserve::Int\n    max_quantity::Int\n    shares::Vector{Vector{Order}}\nend","category":"page"},{"location":"basic_example/#Initialize-Model","page":"Basic Example","title":"Initialize Model","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The function defined below initializes the agent-based model.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"import ABMPredictionMarkets: initialize\nfunction initialize(\n    ::Type{<:TestAgent};\n    n_agents,\n    μ,\n    η,\n    δ,\n    money,\n    max_quantity = 1,\n)\n    space = nothing\n    n_markets = length(μ)\n    model = StandardABM(\n        TestAgent,\n        space;\n        properties = CDA(; n_markets),\n        agent_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    for _ ∈ 1:n_agents\n        add_agent!(\n            model;\n            judgments = rand(DiscreteDirichlet(μ, η)),\n            money,\n            bid_reserve = 0,\n            δ,\n            max_quantity,\n            shares = init(Order, n_markets)\n        )\n    end\n    return model\nend","category":"page"},{"location":"basic_example/#Run-Model","page":"Basic Example","title":"Run Model","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the code block below, we will initialize the agent-based model for the prediction market and run the simulation for 50 days. The keywords are defined as follows:","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"n_agents: the number of agents participating in the prediction market\nμ: a vector of mean beliefs sampled from a Dirichlet distribution\nη: the precision or inverse variance in the beliefs across agents \nmoney: the size of each agent's budget in cents \nδ: the variability in asks/bids in cents ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"n_agents = 100\nμ = [0.20, 0.25, 0.10, 0.45]\nmodel = initialize(\n    TestAgent;\n    n_agents,\n    μ,\n    η = 20.0,\n    money = 10_000,\n    δ = 3\n)\nrun!(model, 50)","category":"page"},{"location":"basic_example/#Plot-Prices","page":"Basic Example","title":"Plot Prices","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the following code, we will plot the market prices as a function of time. Each line represents the market price for a different prediction market, which are down sampled to the final price each day. The black horizontal lines represent the expected market prices based on μ defined above. Notice that the market prices approximate the expected values. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"market_titles = [L\"e_{1}\" L\"e_{2}\" L\"e_{3}\" L\"e_{4}\"]\nmarket_prices = summarize_by_iteration.(model.market_prices, model.iteration_ids)\nplot(\n    market_prices,\n    ylims = (0, 1),\n    ylabel = \"Market Price\",\n    grid = false,\n    legendtitle = \"Markets\",\n    label = market_titles\n)\nhline!(μ, color = :black, linestyle = :dash, label = nothing)","category":"page"},{"location":"basic_example/#Plot-Trade-Volume","page":"Basic Example","title":"Plot Trade Volume","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The plot below shows trade volume computed as the sum of trades per day.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"trade_volume = summarize_by_iteration.(model.trade_volume, model.iteration_ids; fun = sum)\n\nplot(\n    trade_volume;\n    layout = (2,2),\n    grid = false,\n    label = false,\n    title = market_titles,\n    ylims = (0, 100),\n    plot_title = \"Trade Volume\"\n)","category":"page"},{"location":"basic_example/#Plot-Depth-Chart","page":"Basic Example","title":"Plot Depth Chart","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the code block below, we plot the depth chart for each prediction market. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"depth_charts = plot_depth_chart.(model.order_books)\nplot(depth_charts...; layout = (2, 2), title = market_titles)","category":"page"},{"location":"basic_example/#Plot-Autocorrelation","page":"Basic Example","title":"Plot Autocorrelation","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The plot below shows the autocorrelation between market prices for each prediction market. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"autocors = @. (autocor(filter(x -> !isnan(x), model.market_prices)))\nplot(\n    autocors;\n    xlabel = \"lag\",\n    leg = false, \n    grid = false, \n    layout = (2, 2),\n    title = market_titles,\n    plot_title = \"Autocorrelation\"\n)","category":"page"},{"location":"basic_example/#Plot-Dashboard","page":"Basic Example","title":"Plot Dashboard","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the example below, we create an animated dashboard consisting of depth charts and market prices. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"model = initialize(\n    TestAgent;\n    n_agents,\n    μ,\n    η = 20.0,\n    money = 10_000,\n    δ = 3,\n    max_quantity = 5\n)\n\nanimation = plot_dashboard(model; n_days = 2)\ngif(animation, \"temp.gif\", fps = 8)","category":"page"}]
}
