var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/#ABMPredictionMarkets.AbstractCDA","page":"API","title":"ABMPredictionMarkets.AbstractCDA","text":"AbstractCDA <: AbstractPredictionMarket\n\nAn abstract type for a continuous double auction prediction market. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.AbstractLSR","page":"API","title":"ABMPredictionMarkets.AbstractLSR","text":"AbstractLSR <: AbstractPredictionMarket\n\nAn abstract type for a prediction market using a logarithmic scoring rule. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.AbstractOrder","page":"API","title":"ABMPredictionMarkets.AbstractOrder","text":"AbstractOrder\n\nAn abstract type representing bids and asks. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.AbstractPredictionMarket","page":"API","title":"ABMPredictionMarkets.AbstractPredictionMarket","text":"AbstractPredictionMarket\n\nAn abstract type for a prediction market. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.CDA","page":"API","title":"ABMPredictionMarkets.CDA","text":"CDA <: AbstractCDA\n\nHolds data and order book for a continuous double auction prediction market simulation.\n\nFields\n\norder_books::Vector{Vector{Order}}: outstanding orders (bids and asks). Each sub-vector corresponds to a different market\nmarket_prices::Vector{Vector{Float64}}: the market price in dollars after each interaction. The market price stays the same   if a transaction does not occur. Each sub-vector corresponds to a different market\ninfo_times::Vector{Int}: a vector of days on which new information is provided \ntrade_counts::Vector{Vector{Int}}: each elements represents the number of trades made per step\niteration_ids::Vector{Vector{Int}}`: iteration number on which market prices are recorded\n\nConstructors\n\nCDA(; order_book, market_prices)\n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.DiscreteDirichlet","page":"API","title":"ABMPredictionMarkets.DiscreteDirichlet","text":"DiscreteDirichlet{T} <: ContinuousMultivariateDistribution\n\nA discrete version of Dirchlet distribution which sums to 100. \n\nFields\n\nμ::Vector{T}: mean probabilities which sum to 1\nη::T: a scalar multiple of μ inversely related to variance. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.LSR","page":"API","title":"ABMPredictionMarkets.LSR","text":"LSR <: AbstractLSR\n\nA market maker using the logarithmic scoring rule.\n\nFields\n\nelasticity: elasticity parameter where higher values correspond to less elasticity\nn_shares::Vector{Vector{Int}}:\nmarket_prices::Vector{Vector{Float64}}:\nn_decimals::Int:\ninfo_times::Vector{Int}:\ntrade_made::Vector{Vector{Bool}}:\n\nReferences\n\nBerg, H., & Proebsting, T. A. (2009). Hanson’s automated market maker. The Journal of Prediction Markets, 3(1), 45-59.\n\nHanson, R. (2003). Combinatorial information market design. Information Systems Frontiers, 5, 107-119.\n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.MarketAgent","page":"API","title":"ABMPredictionMarkets.MarketAgent","text":"MarketAgent <: AbstractAgent\n\nAn agent that submits bids and asks in a prediction market. \n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.Order","page":"API","title":"ABMPredictionMarkets.Order","text":"Order <: AbstractOrder\n\nAn object representing a bid, ask, or share. \n\nFields\n\nid::Int: agent id \nyes::Bool: true if represents a yes share \nprice::Int: the price of a single share, price ∈ [0,100]\nquantity::Int: the number of shares at a given price \ntype::Symbol: object type type ∈ [bid,ask,share]\n\nConstructors\n\nOrder(id, yes, price, quantity, type)\n\nOrder(; id, yes, price, quantity, type)\n\n\n\n\n\n","category":"type"},{"location":"api/#ABMPredictionMarkets.agent_step!-Tuple{Any, MarketAgent, AbstractPredictionMarket, Any}","page":"API","title":"ABMPredictionMarkets.agent_step!","text":"agent_step!(agent, ::MarketAgent, ::AbstractPredictionMarket, model)\n\nThe agent submits a new order for a bid or ask in each market.  The order is checked against potential sellers (buyers), and  an exchange is made if one is found. Otherwise, the order is added to the order book.    \n\nArguments\n\nagent: an agent participating in the prediction market\n::MarketAgent: variant of agent possibly of the same type as agent\n::AbstractPredictionMarket: a prediction market type \nmodel: an abm object for the prediction market simulation \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.compute_trade_volume-Tuple{Any, Int64}","page":"API","title":"ABMPredictionMarkets.compute_trade_volume","text":"compute_trade_volume(trade_counts, interval_length)\n\nComputes trade volume for a set of time intervals \n\nArguments\n\ntrade_counts: indicates number of trades per step\ninterval_length: the length of the interval in which trade volume is computed\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.compute_unpacking_factor-Tuple{Any}","page":"API","title":"ABMPredictionMarkets.compute_unpacking_factor","text":"compute_unpacking_factor(model)\n\nComputes the ratio of sum of subevents probabilities to the event probability for a 2×2 partition.  Event e is indexed by 1 and subevents e₁ and e₂ are indexed by 2 and 3. Probability theory requires p(e) = p(e₁) + p(e₂).\n\nArguments \n\nmodel: an abm object for the prediction market simulation \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.summarize_by_iteration-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.summarize_by_iteration","text":"summarize_by_iteration(values, iteration_ids; fun = x -> x[end])\n\nSummarize by iteration using fun\n\nArguments\n\nvalues: a vector of values after each agent step \niteration_ids: a vector containing the indices of iterations for each agent step \n\nKeywords\n\nfun = x -> x[end]: a function applied to market prices of each iteration. By default,\n\nthe ending price is used. \n\n\n\n\n\n","category":"method"},{"location":"api/#Plotting","page":"API","title":"Plotting","text":"","category":"section"},{"location":"api/#ABMPredictionMarkets.plot_depth_chart","page":"API","title":"ABMPredictionMarkets.plot_depth_chart","text":"plot_depth_chart(order_book::Vector{Order}; kwargs...)\n\nCreates a market depth chart to analyze supply and demand dynamics. The red area on the left represents the reversed cumulative distribution for bids. The blue area on the right represents the cumulative distribution for asks.  The mid market price is represented by vertical black line.\n\nArguments\n\norder_book::Vector{Order}: a vector of orders (bids and asks) representing the order book (i.e. outstanding orders)\n\nKeywords\n\nconfig...: optional keyword arguments to the function plot\n\n\n\n\n\n","category":"function"},{"location":"api/#ABMPredictionMarkets.plot_dashboard","page":"API","title":"ABMPredictionMarkets.plot_dashboard","text":"plot_dashboard(\n    model;\n    title = make_title(model.market_prices),\n    size = (1200, 1000),\n    depth_chart_layout = make_layout(model.market_prices),\n    outer_layout = [\n        (label = :a, width = :auto, height = 0.70),\n        (label = :b, width = :auto, height = 0.30)\n    ],\n    add_unpacking_factor = false,\n    n_days = 1,\n    depth_chart_config = (),\n    price_chart_config = (),\n)\n\nPlots an animated dashboard containing the following:\n\nA depth chart for each market. \nHistorical price for each market.\nOptional unpacking factor based on two market sets. \n\nArguments\n\nmodel: an abm object for the prediction market simulation \n\nKeywords\n\ntitle: a 1×n vector of labels for each market. By default, each element is eᵢ\ndepth_chart_layout: the layout of the depth charts. By default, the smallest possible 2D grid is used.\nsize = (1200, 1000): size of dashboard animation \nouter_layout: the layout for the dashboard\nadd_unpacking_factor = false: includes unpacking factor plot if true. If set to true, default layouts will need to be overwritten.\nn_days = 1: the number of days to simulate the prediction market\ndepth_chart_config = (): optional keyword arguments for the depth charts\nprice_chart_config = (): optional keyword arguments for price charts\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Functions","page":"API","title":"Internal Functions","text":"","category":"section"},{"location":"api/#ABMPredictionMarkets.add_shares!-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.add_shares!","text":"add_shares!(shares, share)\n\nAdds a share to a vector of shares. A new element is add if the shares do not have an entry with the target price.  If an entry with the target price exists, the quantity is added to that entry \n\nArguments\n\nshares: a vector of current shares \nshare: a share to be added to shares\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.ask-Tuple{Any, MarketAgent, AbstractCDA, Any, Any}","page":"API","title":"ABMPredictionMarkets.ask","text":"ask(agent, ::MarketAgent, ::AbstractCDA, model, bidx)\n\nGenerates an ask amount according to \n\nv ~ Uniform(p, + 1, p + δ),\n\nwhere p is the maximum share price. \n\nArguments\n\nagent: an agent participating in the prediction market\n::MarketAgent: variant of agent possibly of the same type as agent\n::AbstractPredictionMarket: a prediction market type \nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.ask_bid_match!-NTuple{4, Any}","page":"API","title":"ABMPredictionMarkets.ask_bid_match!","text":"ask_bid_match!(proposal, model, bidx, i)\n\nFor agent i and agent j, let b be the bid amount, a be the ask amount, and e be the event.    If bₑᵢ = aₑⱼ, then exchange. \n\nArgument\n\nproposal: a proposal bid or ask \nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\ni: the index for the current entry of the order book \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.ask_match!-NTuple{4, Any}","page":"API","title":"ABMPredictionMarkets.ask_match!","text":"ask_match!(proposal, model, bidx, i)\n\nFor agent i and agent j, let a be the ask amount, and e be the event.    If aₑᵢ + a¬ₑⱼ = 1, then remove shares and deduct ask amounts for i and j . \n\nArgument\n\nproposal: a proposal bid\nmodel: an abm object for the prediction market simulation \ni: the index for the current entry of the order book \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.bid-Tuple{Any, MarketAgent, AbstractCDA, Any, Any}","page":"API","title":"ABMPredictionMarkets.bid","text":"bid(agent, ::MarketAgent, ::AbstractCDA, model, bidx)\n\nGenerates an ask amount according to \n\nv ~ Uniform(p - δ, p - 1),\n\nwhere p is the agent's subject probability of the event, expressed on a scale ranging from 0 100 (cents). The bid price is subtracted from  money and added to the bid reserve to ensure the agent has sufficient funds when making bids  in multiple markets. \n\nArguments\n\nagent: an agent participating in the prediction market\n::MarketAgent: variant of agent possibly of the same type as agent\n::AbstractPredictionMarket: a prediction market type \nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.bid_match!-NTuple{4, Any}","page":"API","title":"ABMPredictionMarkets.bid_match!","text":"bid_match!(proposal, model, bidx, i)\n\nFor agent i and agent j, let b be the bid amount, and e be the event.    If bₑᵢ + b¬ₑⱼ = 1, then create new shares for i and j. \n\nArgument\n\nproposal: a proposal bid\nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\ni: the index for the current entry of the order book \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.compute_returns-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.compute_returns","text":"compute_returns(shares, p_true)\n\nComputes the expected return of a vector of shares. \n\nArguments\n\nshares: a vector of shares \np_true: the true probability of the event \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.cost_to_price-Tuple{Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.cost_to_price","text":"cost_to_price(cost, price, elasticity)\n\nFinds the total cost of a transaction to move the current price to a new price. \n\nArguments\n\ncost: the total dollar amount of an exchange of shares\nprice: the current price of a given share\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.cost_to_shares-Tuple{Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.cost_to_shares","text":"cost_to_shares(cost, price, elasticity)\n\nFinds the number of shares that can be purchased at a given total cost. \n\nArguments\n\ncost: the toal dollar amount of an exchange of shares\nprice: the current price of a given share\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.create_order-Tuple{Any, MarketAgent, AbstractCDA, Any, Any}","page":"API","title":"ABMPredictionMarkets.create_order","text":"create_order(agent, ::MarketAgent, ::AbstractCDA, model, bidx)\n\nCreates and returns a bid or ask. The function bid is called if the agent has no shares. The function ask is called if the agent has no money. If the agent has money and shares, bid and ask are called with equal probability. \n\nArguments\n\nagent::MarketAgent: an agent participating in the prediction market\n::MarketAgent: variant of agent possibly of the same type as agent\n::AbstractPredictionMarket: a prediction market type \nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.get_market_info-Tuple{Any}","page":"API","title":"ABMPredictionMarkets.get_market_info","text":"get_market_info(order_book; yes)\n\nReturns the maximum bid and minimum ask in the order book. \n\nArguments\n\norder_book: a vector of outstanding orders\n\nKeywords\n\nyes: returns maximum bid and minimum ask for yes orders if true \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.price_to_cost-Tuple{Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.price_to_cost","text":"price_to_cost(new_price, price, elasticity)\n\nFinds the number of shares needed to change to a new price. \n\nArguments\n\nnew_price: the new price after purchacing shares\nprice: the current price of a given share\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.price_to_shares-Tuple{Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.price_to_shares","text":"price_to_shares(new_price, price, elasticity)\n\nFinds the number of shares needed to change to a new price. \n\nArguments\n\nnew_price: the new price after purchacing shares\nprice: the current price of a given share\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.remove_orders!-Tuple{MarketAgent, Any, Any}","page":"API","title":"ABMPredictionMarkets.remove_orders!","text":" remove_orders!(agent::MarketAgent, model, bidx)\n\nRemoves orders from the specified order book and transfers funds from the bid reserve to the agent's money fund.     \n\nArguments\n\nagent::MarketAgent: an agent participating in the prediction market\nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.sample_ask-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.sample_ask","text":"sample_ask(p, δ)\n\nSamples an amount to ask.  \n\nv ~ Uniform(p, + 1, p + δ),\n\nwhere p is typically the maximum share price. \n\nArguments\n\np: is typically the maximum share price. p ∈ [0, 100]\nδ: the range of noise added to ask price. δ ≥ 1.  \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.sample_bid-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.sample_bid","text":"sample_bid(judgment, δ)\n\nSamples an amount to ask.  \n\nv ~ Uniform(judgment, - δ, judgment - 1),\n\nwhere judgment is the agent's subjective probability. \n\nArguments\n\njudgment: s the agent's subjective probability. judgment ∈ [0, 100]\nδ: the range of noise added to ask price. δ ≥ 1.  \n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.set_elasticity-Tuple{Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.set_elasticity","text":"set_elasticity(total_money, n_events, upper_price)\n\nSets the elasticity parameter to a value such that an upper price is achieved if all money      in a market allocated to a given event. \n\nArguments\n\ntotal_money: total money in a given market across all participants \nn_events: the number of events that can be purchased in a given market\nupper_price: the maximum price, achieved if all money is placed on a single event\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.shares_to_cost-Tuple{Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.shares_to_cost","text":"shares_to_cost(prices, n_shares, elasticity)\n\nFinds the cost given a number of shares and current price. \n\nArguments\n\nprice: the current price of a given share\nn_shares: the number of shares purchased\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.shares_to_price-Tuple{Any, Any, Any}","page":"API","title":"ABMPredictionMarkets.shares_to_price","text":"shares_to_price(price, n_shares, elasticity)\n\nFinds the new price given a number of shares and current price. \n\nArguments\n\nprice: the current price of a given share\nn_shares: the number of shares purchased\nelasticity: the elasticity parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.to_beta-Tuple{Any, Any}","page":"API","title":"ABMPredictionMarkets.to_beta","text":"to_beta(μ, σ)\n\nReturns α and β parameters of beta distribution corresponding to the desired mean and  standard deviation. \n\nArguments\n\nμ: the desired mean of the beta distribution \nσ: the desired standard deviation of the beta distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#ABMPredictionMarkets.transact!-Tuple{Any, AbstractCDA, Any, Any}","page":"API","title":"ABMPredictionMarkets.transact!","text":"transact!(proposal, ::AbstractCDA, model, bidx)\n\nAttempts to find a possible trade for a submitted proposal (bid or ask). Returns true if the proposal trade was performed. Otherwise, false is returned. If the proposed trade is not completed, the proposal is added to  the order book.\n\nArguments\n\nproposal: a proposal bid or ask \n::AbstractCDA: a double continuous auction prediction market\nmodel: an abm object for the prediction market simulation \nbidx: the index of the current order book\n\n\n\n\n\n","category":"method"},{"location":"custom_example/#Custom-Example","page":"Custom Example","title":"Custom Example","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"The purpose of this tutorial is to demonstrate how to create an agent with custom behavior. The example below consists of two agent types: ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"subadditive agent: an agent whose beliefs about a set of prediction markets are subadditive (i.e., exceeds 1), and thus violate probability theory.\narbitrage agent: an agent who exploits subadditive markets by purchasing no shares in each market.","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"Our example will demonstrate the value of arbitrage in correcting prices by comparing two conditions: (1) a no arbitrage condition consisting of 100 subadditive agents and zero arbitrage agents, and (2) an arbitrage condition consisting of 70 subadditive agents and 30 arbitrage agents. In the arbigtrage condition, the arbitrage agents will reduce subadditivity by renormalizing the market prices. ","category":"page"},{"location":"custom_example/#Sub-Additivity","page":"Custom Example","title":"Sub-Additivity","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"In this section, we provide a more formal explanation of subadditivity. Suppose the sample space boldsymbolOmega is partitioned into a set of mutually exclusive and exhaustive sub-events: boldsymbolOmega = e_1e_2 dots e_n. According to probability theory, the probabilities must be additive:  ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"p(e_1 cup e_2 cup dots cup e_n) = sum_e_i in boldsymbolOmega p(e_i) = 1","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"In other words, the sum of the probabilities across all sub-events must sum to 1. This logic extends to prediction markets because the market price is interpreted as a crowd sourced probability estimate.  Below, we will create a set of binary prediction markets covering events in boldsymbolOmega: ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"mathbfM = (e_1 bare_1)(e_2 bare_2) dots (e_n bare_n)","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"Each market consists of and event e_i represented by yes shares and its complementary event bare_i represented by no shares. If additivity is satisfied, the sum of yes prices should approximate 1 at each time point. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"Click on the ▶ icon to reveal a full version of the code.  ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"<details>\n<summary><b>Full Code</b></summary>","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: get_market\nusing ABMPredictionMarkets: get_min_ask\nusing ABMPredictionMarkets: init\nusing ABMPredictionMarkets: transact!\nusing Agents\nusing Plots\nusing Statistics\nimport ABMPredictionMarkets: agent_step!\n\n@agent struct SubadditiveAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Int}\n    δ::Int\n    money::Int\n    bid_reserve::Int\n    max_quantity::Int\n    shares::Vector{Vector{Order}}\nend\n\n@agent struct ArbitrageAgent(NoSpaceAgent) <: MarketAgent\n    money::Int\n    bid_reserve::Int\n    shares::Vector{Vector{Order}}\nend\n\n\n@multiagent MultiAgent(ArbitrageAgent, SubadditiveAgent) <: MarketAgent\n\nfunction agent_step!(agent, ::ArbitrageAgent, ::AbstractPredictionMarket, model)\n    no_prices = get_no_prices(model)\n    cost, win = eval_arbitrage(no_prices, 0)\n    if (cost < win) && (agent.money ≥ cost)\n        for bidx ∈ 1:length(model.order_books)\n            order = Order(;id = agent.id, yes = false, price = no_prices[bidx], quantity = 1, type = :bid)\n            transact!(order, model, bidx)\n        end\n    else\n        for bidx ∈ 1:length(model.order_books) \n            push!(model.trade_counts[bidx], 0)\n            push!(model.iteration_ids[bidx], abmtime(model))\n            market_prices = model.market_prices[bidx]\n            isempty(market_prices) ? push!(market_prices, NaN) :\n            push!(market_prices, market_prices[end])\n        end\n    end\n    return nothing\nend\n\nfunction eval_arbitrage(no_prices, fee_percent)\n    n_win = length(no_prices) - 1\n    win = n_win * 100\n    cost = sum(no_prices)\n    fees = sum(compute_fee.(fee_percent, sort(no_prices[1:n_win])))\n    return (;cost, win = win - fees)\nend\n\ncompute_fee(fee_percent, price) = fee_percent * min(price, 100 - price) * (100 / price)\n\nfunction get_no_prices(model)\n    return get_min_ask.(model.order_books; yes = false)\nend\n\nfunction initialize(\n    standard_type::Type{<:SubadditiveAgent},\n    arbitrage_type::Type{<:ArbitrageAgent};\n    n_subadditive,\n    n_arbitrage,\n    μ,\n    η,\n    δ,\n    money,\n    max_quantity = 1,\n    unpacking_factor,\n    info_times = Int[]\n)\n    space = nothing\n    n_markets = length(μ)\n    model = StandardABM(\n        MultiAgent,\n        space;\n        properties = CDA(; n_markets, info_times),\n        agent_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    id = 0\n    for _ ∈ 1:n_subadditive\n        id += 1\n        judgments = Int.(round.(rand(DiscreteDirichlet(μ, η)) * unpacking_factor))\n        agent = (MultiAgent ∘ standard_type)(;\n            id,\n            judgments,\n            money,\n            bid_reserve = 0,\n            δ,\n            max_quantity,\n            shares = init(Order, n_markets)\n        )\n        add_agent!(agent, model)\n    end\n    for _ ∈ 1:n_arbitrage\n        id += 1\n        agent = (MultiAgent ∘ arbitrage_type)(;\n            id,\n            money,\n            bid_reserve = 0,\n            shares = init(Order, n_markets)\n        )\n        add_agent!(agent, model)\n    end\n    return model\nend\n\nRandom.seed!(5064)\n\nconfig = (\n    μ = [0.45, 0.20, 0.25, 0.10],\n    η = 20.0,\n    unpacking_factor = 1.3,\n    δ = 3,\n    money = 5000,\n    max_quantity = 1,\n)\n\nno_arbitrage_model = initialize(\n    SubadditiveAgent,\n    ArbitrageAgent;\n    n_subadditive = 100,\n    n_arbitrage = 0,\n    config...\n)\n\narbitrage_model = initialize(\n    SubadditiveAgent,\n    ArbitrageAgent;\n    n_subadditive = 70,\n    n_arbitrage = 30,\n    config...\n)\n\nrun!(no_arbitrage_model, 100)\nrun!(arbitrage_model, 100)\n\nno_arbitrage_market_prices = summarize_by_iteration.(no_arbitrage_model.market_prices, no_arbitrage_model.iteration_ids)\n\nplot(\n    sum(no_arbitrage_market_prices),\n    ylims = (0, 2),\n    xlabel = \"Day\", \n    ylabel = \"Unpacking Factor\",\n    grid = false,\n    label = \"No Arbitriage\",\n)\nhline!([1], color = :black, linestyle = :dash, label = nothing)\n\narbitrage_market_prices = summarize_by_iteration.(arbitrage_model.market_prices, arbitrage_model.iteration_ids)\nplot!(sum(arbitrage_market_prices), label = \"Arbitriage\")","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"</details>","category":"page"},{"location":"custom_example/#Load-Dependencies","page":"Custom Example","title":"Load Dependencies","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"Our first step is to load the required dependencies for simulation and plotting. In addition, we will import the function agent_step! so we can create a new method defining the behavior of the subadditive agent. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: get_market\nusing ABMPredictionMarkets: get_min_ask\nusing ABMPredictionMarkets: init\nusing ABMPredictionMarkets: transact!\nusing Agents\nusing Plots\nusing Statistics\nimport ABMPredictionMarkets: agent_step!","category":"page"},{"location":"custom_example/#Define-Agents","page":"Custom Example","title":"Define Agents","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"Below, we define agent types which is are subtype of MarketAgent. ","category":"page"},{"location":"custom_example/#Subadditive-Agents","page":"Custom Example","title":"Subadditive Agents","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"As the name implies, the probability judgments of the subadditive agent are subadditive. The subadditive agent has the following fields:","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"judgments::Vector{Int}: a vector of probabilities for each event expressed in cents, which sum to a value greater than 100 because they are subadditive. \nδ::Int: the degree of variability in bids and asks expressed in cents. \nmoney::Int: the amount of money available to the agent expressed in cents. \nbid_reserve::Int: the amount of money reserved for bids in the order book for ensuring sufficient funds\nmax_quantity::Int the maximum quantity of shares per order\nshares::Vector{Vector{Order}}: a constaining for storing the shares owned by the agent. Each sub-vector corresponds to a shares for a sub-event. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"On each simulated day when the function agent_step! is called for a subadditive agent, it submits a bid or ask in each available market. Roughly speaking, it accepts the maximum bid or minimum ask if it is advantageous. Otherwise, it submits an order for an ask or bid with uniform variable and a range of delta cents. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"@agent struct SubadditiveAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Int}\n    δ::Int\n    money::Int\n    bid_reserve::Int\n    max_quantity::Int\n    shares::Vector{Vector{Order}}\nend","category":"page"},{"location":"custom_example/#Arbitrage-Agent","page":"Custom Example","title":"Arbitrage Agent","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"The goal of the arbitrage agent is to exploit sub-additive prices by purchacing no shares for all markets. Using this strategy guarantees a payout of 1 dollar for n-1 shares, i.e., all shares except the share whose complementary event occured. Assuming prices are sub-additive (i.e., sum_i=1^n e_i 1), then the cost of no shares for all markets, c,  must be less than the payout: c  n - 1. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"<details>\n<summary><b>Mathematical Details</b></summary>","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"To see why, note the cost c is","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"c = sum_i=1^n bare_i","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"c = sum_i=1^n 1 - e_i","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"c = sum_i=1^n 1 - sum_i=1^n e_i","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"c = n - sum_i=1^n e_i","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"Substituting n - sum_i=1^n e_i into c  n-1, we have","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"n - sum_i=1^n e_i  n - 1","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"sum_i=1^n e_i  1","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"which is consistent with our assumption of sub-additivity.","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"</details>","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"The arbitrage agent has a subset of fields defined above for the subadditive agent. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"@agent struct ArbitrageAgent(NoSpaceAgent) <: MarketAgent\n    money::Int\n    bid_reserve::Int\n    shares::Vector{Vector{Order}}\nend","category":"page"},{"location":"custom_example/#Multi-Agent","page":"Custom Example","title":"Multi-Agent","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"To improve performance, we will wrap the two agent types into a MultiAgent type with the @multiagent macro.","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"@multiagent MultiAgent(ArbitrageAgent, SubadditiveAgent) <: MarketAgent","category":"page"},{"location":"custom_example/#Agent-Step-Function","page":"Custom Example","title":"Agent Step Function","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"The behavior of the arbitrage agent in the agent_step! method below. The function works as follows. First, the agent determines whether it can exploit subadditive prices. Second, if it can, it submits an order for a no share in each market. Otherwise, it records the previous market price as the current market price. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"function agent_step!(agent, ::ArbitrageAgent, ::AbstractPredictionMarket, model)\n    no_prices = get_no_prices(model)\n    cost, win = eval_arbitrage(no_prices, 0)\n    if (cost < win) && (agent.money ≥ cost)\n        for bidx ∈ 1:length(model.order_books)\n            order = Order(;id = agent.id, yes = false, price = no_prices[bidx], quantity = 1, type = :bid)\n            transact!(order, model, bidx)\n        end\n    else\n        for bidx ∈ 1:length(model.order_books) \n            push!(model.trade_counts[bidx], 0)\n            push!(model.iteration_ids[bidx], abmtime(model))\n            market_prices = model.market_prices[bidx]\n            isempty(market_prices) ? push!(market_prices, NaN) :\n            push!(market_prices, market_prices[end])\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"custom_example/#Arbitrage-Functions","page":"Custom Example","title":"Arbitrage Functions","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"The code block defines three helper functions for arbitrage. Given a vector of no prices and a free percent, the function eval_arbitrage returns the cost and the payout for buying no shares in each prediction market. The function compute_fee returns the fees Polymarket applies to winnings. In our example, we assume for simplicity that the fee is zero percent. Finally, the function get_all_no_prices returns a vector of asking prices for no shares in each market. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"function eval_arbitrage(no_prices, fee_percent)\n    n_win = length(no_prices) - 1\n    win = n_win * 100\n    cost = sum(no_prices)\n    fees = sum(compute_fee.(fee_percent, sort(no_prices[1:n_win])))\n    return (;cost, win = win - fees)\nend\n\ncompute_fee(fee_percent, price) = fee_percent * min(price, 100 - price) * (100 / price)\n\nfunction get_no_prices(model)\n    return get_min_ask.(model.order_books; yes = false)\nend","category":"page"},{"location":"custom_example/#Model-Initialization-Function","page":"Custom Example","title":"Model Initialization Function","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"In the code block below, we define a function that initializes the model and adds agents to the newly created model. The model has no spatial component because agents do not need to move in their environment. The model uses a type of prediction market called a continuous double action (see the type CDA). In addition, the scheduler randomizes the order in each agents perform their actions on each day. The function requires the following keyword arguments:","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"n_subadditive: the number of subadditive agents in the simulation\nn_arbitrage: the number of arbitrage agents in the simulation\nμ: the mean probability judgments sampled from a Dirichlet distribution\nη: the precession of probability judgments sampled from a Dirichlet distribution\nδ::Int: the degree of variability in bids and asks expressed in cents. \nmoney: the initial amount of money given to each agent\nmax_quantity = 1: the maximum number of shares per order for each agent per day\nunpacking_factor: controls the degree of subadditivity in the judgments of the subadditive agents\ninfo_times = Int[]: required keyword argument that is not needed for this model","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"function initialize(\n    standard_type::Type{<:SubadditiveAgent},\n    arbitrage_type::Type{<:ArbitrageAgent};\n    n_subadditive,\n    n_arbitrage,\n    μ,\n    η,\n    δ,\n    money,\n    max_quantity = 1,\n    unpacking_factor,\n    info_times = Int[]\n)\n    space = nothing\n    n_markets = length(μ)\n    model = StandardABM(\n        MultiAgent,\n        space;\n        properties = CDA(; n_markets, info_times),\n        agent_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    id = 0\n    for _ ∈ 1:n_subadditive\n        id += 1\n        judgments = Int.(round.(rand(DiscreteDirichlet(μ, η)) * unpacking_factor))\n        agent = (MultiAgent ∘ standard_type)(;\n            id,\n            judgments,\n            money,\n            bid_reserve = 0,\n            δ,\n            max_quantity,\n            shares = init(Order, n_markets)\n        )\n        add_agent!(agent, model)\n    end\n    for _ ∈ 1:n_arbitrage\n        id += 1\n        agent = (MultiAgent ∘ arbitrage_type)(;\n            id,\n            money,\n            bid_reserve = 0,\n            shares = init(Order, n_markets)\n        )\n        add_agent!(agent, model)\n    end\n    return model\nend","category":"page"},{"location":"custom_example/#Set-RNG-Seed","page":"Custom Example","title":"Set RNG Seed","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"The next code block sets the seed for the random number generator to ensure the results are reproducible. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"Random.seed!(5064)","category":"page"},{"location":"custom_example/#Initialize-Models","page":"Custom Example","title":"Initialize Models","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"In this section, we create models for the no arbitrage condition and the arbitrage condition with the function called initialize. The code block below defines a NamedTuple of the common parameters for each model. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"config = (\n    μ = [0.45, 0.20, 0.25, 0.10],\n    η = 20.0,\n    unpacking_factor = 1.3,\n    δ = 3,\n    money = 5000,\n    max_quantity = 1,\n)","category":"page"},{"location":"custom_example/#No-Arbitrage-Model","page":"Custom Example","title":"No Arbitrage Model","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"The defining feature of the no arbitrage model is the absence of arbitrage agents. Specifically, we set the number of subadditive agents to 100 and the number of arbitrage agents to 0. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"no_arbitrage_model = initialize(\n    SubadditiveAgent,\n    ArbitrageAgent;\n    n_subadditive = 100,\n    n_arbitrage = 0,\n    config...\n)","category":"page"},{"location":"custom_example/#Arbitrage-Model","page":"Custom Example","title":"Arbitrage Model","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"By contrast, the arbitrage model does include arbitrage agents. Specifically, we set the number of subadditive agents to 70 and the number of arbitrage agents to 30. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"arbitrage_model = initialize(\n    SubadditiveAgent,\n    ArbitrageAgent;\n    n_subadditive = 70,\n    n_arbitrage = 30,\n    config...\n)","category":"page"},{"location":"custom_example/#Run-Models","page":"Custom Example","title":"Run Models","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"In the code block below, we run each model for 100 days. Agents sequentially perform their actions in a different random order each day. ","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"run!(no_arbitrage_model, 100)\nrun!(arbitrage_model, 100)","category":"page"},{"location":"custom_example/#Plot-Results","page":"Custom Example","title":"Plot Results","text":"","category":"section"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"In the plot below, we plot the ending market price each day for the no arbitrage and arbitrage models. As expected, both models show evidence of subadditivity (i.e., the data points are above 1), but the degree of subadditivity is less pronounced in the arbitrage model, indicating arbitrage agents were able to exploit the mispriced markets and partially correct the prices.","category":"page"},{"location":"custom_example/","page":"Custom Example","title":"Custom Example","text":"no_arbitrage_market_prices = summarize_by_iteration.(no_arbitrage_model.market_prices, no_arbitrage_model.iteration_ids)\nplot(\n    sum(no_arbitrage_market_prices),\n    ylims = (0, 2),\n    xlabel = \"Day\", \n    ylabel = \"Unpacking Factor\",\n    grid = false,\n    label = \"No Arbitriage\",\n)\nhline!([1], color = :black, linestyle = :dash, label = nothing)\narbitrage_market_prices = summarize_by_iteration.(arbitrage_model.market_prices, arbitrage_model.iteration_ids)\nplot!(sum(arbitrage_market_prices), label = \"Arbitriage\")","category":"page"},{"location":"#ABMPredictionMarkets","page":"Home","title":"ABMPredictionMarkets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project contains an API for creating agent-based models of prediction markets. More details can be found by navigating the menu on the left-hand side.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/temp.gif\" width=1200 height=800>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details>\n<summary><b>Show Details </b></summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Random\nusing Agents\nusing Plots\nusing ABMPredictionMarkets\nRandom.seed!(568)\n\nn_agents = 200\nmodel = initialize(\n    TestAgent;\n    n_agents,\n    μ = [0.20, 0.25, 0.10, 0.45],\n    η = 20.0,\n    money = 50000,\n    δ = 3,\n    info_times = Int[],\n    n_markets = 5\n)\n\nanimation = plot_dashboard(model)\ngif(animation, \"temp.gif\", fps = 8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"basic_example/#Basic-Example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The page provides a working example of simulating a prediction market with ABMPredictionMarkets.jl. In the example below, 100 agents trade shares in four prediction markets. The belief distributions across agents are distributed such that the sum of prices is approximately 1. Click on the ▶ icon to reveal a full version of the code.  ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"<details>\n<summary><b>Full Code</b></summary>","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: init\nusing Agents\nusing Distributions\nusing LaTeXStrings\nusing Plots\nusing Random\nusing StatsBase\nRandom.seed!(93)\n\n@agent struct TestAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Int}\n    δ::Int\n    money::Int\n    bid_reserve::Int\n    max_quantity::Int\n    shares::Vector{Vector{Order}}\nend\n\nimport ABMPredictionMarkets: initialize\nfunction initialize(\n    ::Type{<:TestAgent};\n    n_agents,\n    μ,\n    η,\n    δ,\n    money,\n    max_quantity = 1,\n    info_times = Int[]\n)\n    space = nothing\n    n_markets = length(μ)\n    model = StandardABM(\n        TestAgent,\n        space;\n        properties = CDA(; n_markets, info_times),\n        agent_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    for _ ∈ 1:n_agents\n        add_agent!(\n            model;\n            judgments = rand(DiscreteDirichlet(μ, η)),\n            money,\n            bid_reserve = 0,\n            δ,\n            max_quantity,\n            shares = init(Order, n_markets)\n        )\n    end\n    return model\nend\n\nn_agents = 100\nμ = [0.20, 0.25, 0.10, 0.45]\nmodel = initialize(\n    TestAgent;\n    n_agents,\n    μ,\n    η = 20.0,\n    money = 10_000,\n    δ = 3\n)\nrun!(model, 50)\n\nmarket_titles = [L\"e_{1}\" L\"e_{2}\" L\"e_{3}\" L\"e_{4}\"]\nmarket_prices = summarize_by_iteration.(model.market_prices, model.iteration_ids)\nplot(\n    market_prices,\n    ylims = (0, 1),\n    ylabel = \"Market Price\",\n    grid = false,\n    legendtitle = \"Markets\",\n    label = market_titles\n)\nhline!(μ, color = :black, linestyle = :dash, label = nothing)\n\ntrade_volume = summarize_by_iteration.(model.trade_counts, model.iteration_ids; fun = sum)\n\nplot(\n    trade_volume;\n    layout = (2,2),\n    grid = false,\n    label = false,\n    title = market_titles,\n    ylims = (0, 100),\n    plot_title = \"Trade Volume\"\n)\n\ndepth_charts = plot_depth_chart.(model.order_books)\nplot(depth_charts...; layout = (2, 2), title = market_titles)\n\nautocors = @. (autocor(filter(x -> !isnan(x), model.market_prices)))\nplot(\n    autocors;\n    xlabel = \"lag\",\n    leg = false,\n    grid = false,\n    layout = (2, 2),\n    title = market_titles,\n    plot_title = \"Autocorrelation\"\n)\n\nmodel = initialize(\n    TestAgent;\n    n_agents,\n    μ,\n    η = 20.0,\n    money = 10_000,\n    δ = 3,\n    max_quantity = 5\n)\n\nanimation = plot_dashboard(model; n_days = 2)\ngif(animation, \"temp.gif\", fps = 8)","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"</details>","category":"page"},{"location":"basic_example/#Load-Dependencies","page":"Basic Example","title":"Load Dependencies","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The next step is to load the required dependencies for simulation and plotting.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"using ABMPredictionMarkets\nusing ABMPredictionMarkets: init\nusing Agents\nusing Distributions\nusing LaTeXStrings\nusing Plots\nusing Random\nusing StatsBase\nRandom.seed!(93)","category":"page"},{"location":"basic_example/#Define-Agent","page":"Basic Example","title":"Define Agent","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Below, we define an agent type which is a subtype of MarketAgent. The subjective judgments are stored in the field judgements for each market on a scale of 0 to 100 (e.g., cents). The money and bid reserve are also expressed in terms of cents. The maximum quantity is the maximum number of shares traded per day per agent. Finally, the field shares stores shares in separate sub-vectors for each market. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"@agent struct TestAgent(NoSpaceAgent) <: MarketAgent\n    judgments::Vector{Int}\n    δ::Int\n    money::Int\n    bid_reserve::Int\n    max_quantity::Int\n    shares::Vector{Vector{Order}}\nend","category":"page"},{"location":"basic_example/#Initialize-Model","page":"Basic Example","title":"Initialize Model","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The function defined below initializes the agent-based model.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"import ABMPredictionMarkets: initialize\nfunction initialize(\n    ::Type{<:TestAgent};\n    n_agents,\n    μ,\n    η,\n    δ,\n    money,\n    max_quantity = 1,\n    info_times = Int[]\n)\n    space = nothing\n    n_markets = length(μ)\n    model = StandardABM(\n        TestAgent,\n        space;\n        properties = CDA(; n_markets, info_times),\n        agent_step!,\n        scheduler = Schedulers.Randomly()\n    )\n    for _ ∈ 1:n_agents\n        add_agent!(\n            model;\n            judgments = rand(DiscreteDirichlet(μ, η)),\n            money,\n            bid_reserve = 0,\n            δ,\n            max_quantity,\n            shares = init(Order, n_markets)\n        )\n    end\n    return model\nend","category":"page"},{"location":"basic_example/#Run-Model","page":"Basic Example","title":"Run Model","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the code block below, we will initialize the agent-based model for the prediction market and run the simulation for 50 days. The keywords are defined as follows:","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"n_agents: the number of agents participating in the prediction market\nμ: a vector of mean beliefs sampled from a Dirichlet distribution\nη: the precision or inverse variance in the beliefs across agents \nmoney: the size of each agent's budget in cents \nδ: the variability in asks/bids in cents ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"n_agents = 100\nμ = [0.20, 0.25, 0.10, 0.45]\nmodel = initialize(\n    TestAgent;\n    n_agents,\n    μ,\n    η = 20.0,\n    money = 10_000,\n    δ = 3\n)\nrun!(model, 50)","category":"page"},{"location":"basic_example/#Plot-Prices","page":"Basic Example","title":"Plot Prices","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the following code, we will plot the market prices as a function of time. Each line represents the market price for a different prediction market, which are down sampled to the final price each day. The black horizontal lines represent the expected market prices based on μ defined above. Notice that the market prices approximate the expected values. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"market_titles = [L\"e_{1}\" L\"e_{2}\" L\"e_{3}\" L\"e_{4}\"]\nmarket_prices = summarize_by_iteration.(model.market_prices, model.iteration_ids)\nplot(\n    market_prices,\n    ylims = (0, 1),\n    ylabel = \"Market Price\",\n    grid = false,\n    legendtitle = \"Markets\",\n    label = market_titles\n)\nhline!(μ, color = :black, linestyle = :dash, label = nothing)","category":"page"},{"location":"basic_example/#Plot-Trade-Volume","page":"Basic Example","title":"Plot Trade Volume","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The plot below shows trade volume computed as the sum of trades per day.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"trade_volume = summarize_by_iteration.(model.trade_counts, model.iteration_ids; fun = sum)\n\nplot(\n    trade_volume;\n    layout = (2,2),\n    grid = false,\n    label = false,\n    title = market_titles,\n    ylims = (0, 100),\n    plot_title = \"Trade Volume\"\n)","category":"page"},{"location":"basic_example/#Plot-Depth-Chart","page":"Basic Example","title":"Plot Depth Chart","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the code block below, we plot the depth chart for each prediction market. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"depth_charts = plot_depth_chart.(model.order_books)\nplot(depth_charts...; layout = (2, 2), title = market_titles)","category":"page"},{"location":"basic_example/#Plot-Autocorrelation","page":"Basic Example","title":"Plot Autocorrelation","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The plot below shows the autocorrelation between market prices for each prediction market. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"autocors = @. (autocor(filter(x -> !isnan(x), model.market_prices)))\nplot(\n    autocors;\n    xlabel = \"lag\",\n    leg = false, \n    grid = false, \n    layout = (2, 2),\n    title = market_titles,\n    plot_title = \"Autocorrelation\"\n)","category":"page"},{"location":"basic_example/#Plot-Dashboard","page":"Basic Example","title":"Plot Dashboard","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the example below, we create an animated dashboard consisting of depth charts and market prices. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"model = initialize(\n    TestAgent;\n    n_agents,\n    μ,\n    η = 20.0,\n    money = 10_000,\n    δ = 3,\n    max_quantity = 5\n)\n\nanimation = plot_dashboard(model; n_days = 2)\ngif(animation, \"temp.gif\", fps = 8)","category":"page"}]
}
